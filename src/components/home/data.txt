[
  {
id: "5a37c17dd92f2f5b185acfc4",
author_id: "4efc278525fa69ac6900000f",
tab: "share",
content: "<div class="markdown-text"><p><img src="https: //dn-cnode.qbox.me/FuvPQvPz9RBxT07UrcBumIxmg-8G" alt="1.png"></p> <h2>大会简介</h2> <p>SEE = Seeking Experience & Engineering，意为探索用户体验与工程实践，由蚂蚁金服集团每年举办 1-2 次，包括专业分享、产品展台、Workshop 等内容。希望通过 SEE Conf，能与业界同行一起分享交流体验科技的当前进展，一起探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p> <p>首届 <a href="https://seeconf.alipay.com/">SEE Conf</a> 将于 2018.01.06 在美丽的浙江杭州举办，届时我们将邀请数百位来自前端、设计、产品等领域的英才，围绕「极致用户体验」和「最佳工程实践」两大主题进行探讨交流。</p> <h2>特邀嘉宾</h2> <ul> <li>蚂蚁金服副总裁：胡喜 (阿玺)</li> <li>美团高级技术总监 ／ 业务负责人：刘平川 (rank)</li> <li>饿了么大前端部门负责人：林建锋 (sofish)</li> <li>百姓网资深前端架构师：贺师俊 (hax)</li> <li>豆瓣资深前端架构师：张克军 (kejun）</li> <li>钉钉资深技术专家：石玉磊 (佩玉)</li> <li>支付宝 UED 负责人：梁山鹰 (隼飞)</li> <li>蚂蚁金服体验技术部负责人：王保平 (玉伯)</li> </ul> <h2>会议日程</h2> <p>大会于 2018.01.06 正式召开，当天日程如下：</p> <ul> <li>09:00 - 09:15：开幕致辞</li> <li>09:15 - 10:00：蚂蚁中台设计体系 —— Ant Design 3.0 背后的故事</li> <li>10:00 - 10:45：Developer Experience First —— TWA 的理念与实践</li> <li>10:45 - 11:30：惊艳的互联网互动体验 —— AntG</li> <li>11:30 - 13:30：午间休息</li> <li>13:30 - 14:15：TECH 模型：企业级中后台产品体验度量探索</li> <li>14:15 - 15:00：AntV，返璞归真幻化万千可视化表达</li> <li>15:00 - 15:45：蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE</li> <li>15:45 - 16:30：轻推转型之门：Ant Design Pro 在企业级产品的探索</li> <li>16:30 - 16:45：从前端技术到体验科技，暨蚂蚁体验云起航</li> <li>16:45 - 17:15：圆桌 —— 体验科技的发展及未来</li> </ul> <h2>大会看点</h2> <p>这是蚂蚁金服体验科技首次对外发声，有大家熟悉的各个明星产品。有一个产品，过去 14 个月在 GitHub 的 star 数从 4k 飙升至 2w+， 这是蚂蚁设计语言 <a href="https://ant.design/index-cn">Ant Design</a>，她是在怎样的业务土壤与团队文化中成长起来的？背后有着怎样的故事？还有一个产品，刚一开源就得到世界级计算机科学家 <a href="https://www.cs.uic.edu/~wilkinson/">Leland Wilkinson</a> 的肯定，这款技术产品是 <a href="https://github.com/antvis/g2">G2</a>，其背后更大的蚂蚁可视化 <a href="https://antv.alipay.com/zh-cn/index.html">AntV</a> 体系是本着怎样的初心在坚持前行？回顾过往，基于 Node.js 的前后端分层这几年在阿里经历了怎样的风雨？什么是 BFF（Backend For Frontend）架构？更进一步的 <strong>TWA</strong>（Techless Web App）架构是为了解决什么问题？为企业级框架和应用而生的 <a href="https://eggjs.org/">Egg.js</a> 将走向何方？</p> <p>除此之外，还有最前沿的移动研发 IDE 技术和企业级产品体验度量的探索分享，更有未曾对外曝光，但已适配了千万机型的 Web 互动图形技术 AntG 将首度登台。从前端技术到体验科技，玉伯这位前端圈里的传奇黑侠将为我们讲述的“<strong>蚂蚁体验云</strong>”究竟是什么。</p> <p><img src="https://gw.alipayobjects.com/zos/rmsportal/ODVJIUEvmuKCwXqqJPfo.jpg" alt></p> <p>技术大会不光能听到干货，还能面基好友结交各路大神。除了议程提到的众多明星嘉宾，从目前报名中已经发现数十位重量级人物，不乏知名公司的产品、设计总监，架构师，新锐公司的 CXO 和领域新秀。</p> <p>另外，蚂蚁金服是个藏龙卧虎的地方，有知名博主，也有知乎网红，有 Node.js、Ruby 等各个技术社区的大拿，还有仙剑主程、艺术插画大师，图形图像、数据可视化专家也会出没会场，有的还当起了会场志愿者在门口热切地期待着你的到来。他们会游走在会场与各个展台之间，也许就坐在你身边，这是面基好友结交大神的好时候，机会难得。</p> <p><img src="https://gw.alipayobjects.com/zos/rmsportal/DdjWkCAawyOMhFnLpGLK.jpg" alt></p> <h2>如何报名</h2> <p>访问 <a href="https://seeconf.alipay.com/">SEE Conf · 蚂蚁金服体验科技大会</a>，点击「立即报名」按钮</p> <p>支付宝扫描下方二维码</p> <p><img src="https://gw.alipayobjects.com/zos/rmsportal/gmcvvumwUehXYbTPBPno.gif" alt></p> </div>",
title: "首届蚂蚁金服体验科技大会",
last_reply_at: "2018-01-21T09:51:48.428Z",
good: false,
top: true,
reply_count: 36,
visit_count: 7518,
create_at: "2017-12-18T13:24:13.334Z",
author: - {
loginname: "fengmk2",
avatar_url: "https://avatars0.githubusercontent.com/u/156269?v=4&s=120"
        }
    },



    
- {
id: "5a2403226190c8912ebaceeb",
author_id: "4f447c2f0a8abae26e01b27d",
tab: "share",
content: "<div class="markdown-text"><p><img src=" //dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w" alt="image.png"></p> <blockquote> <p>原文地址：知乎专栏 <a href="https://zhuanlan.zhihu.com/p/31640541">https://zhuanlan.zhihu.com/p/31640541</a></p> </blockquote> <p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href="https://zhuanlan.zhihu.com/p/25860846">Egg 1.0 版本</a> 时隔 8 个月。</p> <p><img src="//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX" alt="image.png"></p> <blockquote> <p><a href="https://eggjs.org/">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br> 既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br> 它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p> </blockquote> <h2>2.0 特性</h2> <ul> <li>基于 Koa 2.x <ul> <li>异步解决方案直接基于 Async Function 。</li> <li>去除 co 兼容后<a href="https://github.com/eggjs/egg/wiki/co-vs-async">堆栈信息更清晰</a>。</li> </ul> </li> <li>框架层优化带来 <a href="https://eggjs.github.io/benchmark/plot/">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li> <li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li> </ul> <p><img src="//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q" alt="image.png"></p> <h2>如何升级</h2> <p><strong><a href="https://eggjs.org/">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p> <ol> <li>Node.js 使用最新的 LTS 版本（>=8.9.0）。</li> <li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li> <li>检查相关插件是否发布新版本（可选）。</li> <li>重新安装依赖，跑单元测试。</li> </ol> <p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p> <p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href="https://eggjs.org/zh-cn/migration.html">升级指南</a> 进一步升级。</p> <h2>未来规划</h2> <p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p> <p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p> <p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p> <ul> <li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li> <li>社区扶持 <ul> <li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li> <li>分享我们在团队、协作、规范化等方面的经验。</li> <li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li> </ul> </li> <li>国际化，官网和<a href="https://github.com/eggjs/egg/issues/363">文档翻译</a>等。</li> </ul> <p>同时，我们也欢迎社区更多的<a href="https://github.com/orgs/eggjs/projects">参与</a>，一起打造更完善的生态。</p> <p><img src="//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5" alt="image.png"></p> <h2>我们这一年</h2> <p>截止至今天(2017-12-03)：</p> <ul> <li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li> <li>从 1.0 到 2.0，我们一共发布了 <a href="https://github.com/eggjs/egg/releases">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li> <li>开发者体验方面的优化包括：<a href="https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95">断点调试代理</a>，<a href="https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试+覆盖率</a>，<a href="https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2">部署工具</a>，TypeScript 支持，<a href="https://github.com/eggjs/vscode-eggjs">VSCode 插件</a>，文档优化等等。</li> </ul> <p><strong>社区方面：</strong></p> <ul> <li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li> <li>来自 <a href="https://github.com/eggjs/egg/network/dependents">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li> <li><a href="https://npms.io/search?q=egg-">NPM 搜索结果</a>超过 400 个。</li> <li>上层框架： <ul> <li><a href="https://github.com/alibaba/beidou">北斗</a> - Isomorphic framework for server-rendered React apps</li> <li><a href="https://github.com/avetjs/avet">avet</a> - A very comfortable framework for writing isomorphic applications</li> </ul> </li> <li>如果你有好的分享，PR 传送门：<a href="https://github.com/eggjs/awesome-egg">awesome-egg</a></li> </ul> <p><strong>趣味数据：</strong></p> <ul> <li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li> <li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li> <li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li> </ul> <p><strong>分享交流：</strong></p> <ul> <li>在 <a href="http://2017.jsdc.tw/">台灣 JSDC2017 開發者年會</a> 和 <a href="http://2017.imweb.io/index.html#schedule">腾讯IMWebConf</a> 分享了『<a href="https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf">Egg & Node.js 从小工坊走向企业级开发</a>』</li> </ul> <p><img src="//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH" alt="image.png"></p> <ul> <li>Node TSC @张秋怡 在 <a href="https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud">Node Interactive North America 2017</a> 和 <a href="http://nodefest.jp/2017/schedule.html#joyee">東京Node学園祭2017</a> 分享了『<a href="https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf">Node.js at Alibaba</a>』。</li> </ul> <p><img src="//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H" alt="image.png"></p> <ul> <li><a href="/user/ngot">@ngot</a> 在 <a href="https://www.bagevent.com/event/751307">Node Party</a> 分享了『<a href="https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf">Egg.js 在阿里巴巴集团的实践运用</a>』</li> <li>@姜天意 在 <a href="http://2017.imweb.io/index.html#schedule">腾讯IMWebConf</a> 分享了 『<a href="https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf">脆弱的 Node.js</a>』</li> </ul> <h2>写在最后</h2> <p>开源，痛并快乐着。</p> <p><img src="//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs" alt="image.png"></p> </div>",
title: "企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async",
last_reply_at: "2018-01-19T03:55:37.279Z",
good: true,
top: true,
reply_count: 97,
visit_count: 15512,
create_at: "2017-12-03T13:58:58.901Z",
author: - {
loginname: "atian25",
avatar_url: "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
        }
    },
- {
id: "5a54a8a4afa0a121784a8ab0",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><p>很抱歉在首届蚂蚁体验科技 SEE Conf 大会上，给大家讲得有点磕绊不太清楚。今天写下来行诸文字，希望一些思考能与大家进一步交流。（设计师朋友可以跳过前端技术部分，直接看后面章节）</p> <h2>什么是前端技术</h2> <p>第一次接触前端开发是 2002 年大学期间，转眼 15 年多。这些年一直在思考一个问题：究竟什么是前端技术？很长很长一段时间，前端技术的定义非常清晰，就是浏览器端的 HTML、CSS、JS 技术。我们用这些技术做出各种各样的页面，我们是离用户最近的程序员。</p> <p><img src=" //dn-cnode.qbox.me/FuTZzCUKkL_OGOsmrXbXvcqalO-D" alt="v2-356e4bb976792ec0c2ae166405e4b502_hd.jpg"></p> <p>记得 2009 年开始接触 Node，很快前端技术开始爆炸性增长。最开始的变化，是前端压缩工具从基于 Java 的 YUI Compressor 开始切换到基于 Node 实现的 UglifyJS 等工具。除了前端工具上的一路狂奔，在服务端领域也出现了 Express 等框架，前端开始通过 Node 完成服务端模板甚至整个 MVC 层的开发。在蚂蚁金服，服务端层我们更多把 Node 定位为 BFF 层实现，BFF 是 Backend For Frontend 的缩写，翻译成用户体验适配层。</p> <p>BFF 模式下，整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。</p> <p>除了服务端的渗透，从 2013 年开始，阿里开始无线 ALL IN 战略，这对前端影响非常大。有相当多的前端开始转型为 iOS 工程师（转型为 Android 的比较少，有部分 Java 工程师转型成了 Android 开发），没有转型的，也开始大量投入到 Mobile Web 开发。这个大背景下，前端与客户端技术开始互相融合，特别是在容器层。从 2015 年开始，物联网 IoT 逐步兴起，前端开始涉足 IoT 设备上的应用研发。端的本质是 devices，台式机、手机、IoT 设备都是一台台 devices，很多会直接被用户使用，有用户使用的 devices，就会有人机交互需求，就会有前端的工作价值。前端是离用户最近的工程师，这个定位一直没变。</p> <p>非常有意思的是，在移动端的架构里，这几年也出现了基于 RPC 接口 + 网关 + BFF 的架构体系，在研发效率、网络性能等方面均有优势。随着 IoT 应用的涌现与复杂化，我相信最终也会出现 BFF 架构。BFF 模式不仅仅是一种技术架构，从社会分工角度讲，BFF 更是一种多元价值导向的分层架构，每一层都有不错的空间去施展，不仅能发挥工业社会双手的作用，还能使用上双手上面的脑袋。齿轮不再是被动跟着转，而是开始拥有自驱的转动力。同一时期，业界也出现了一些类似的职业融合。比如 DevOps 倡导开发也懂运维，不少大公司在推行开发也懂测试，测试则转型为更专业的质量工具部门，还有前端也懂设计的 DesignOps 的出现等等。各种全栈概念的涌现，都是在重新探索更合理的分层协作模式。纷纷扰扰，成败如风。</p> <p>补充一个说明，当年提出的前后端分离，并不准确，这些年一直努力纠正为前后端分层的理念。专业的分工协同对效能的提升很关键。全栈的含义是指分层演化后，每一层的技术栈要求，是每一层横向技能的全，而不是纵向跨层的通（纵向跨多层都能通的人才非常少，就如当今社会已经非常难诞生博物学家了）。不断探索更好的分层协作是有意思的，这就如人类家庭里夫妻的关系一样，男权、女权都不可取，社会的演化最终会视人为人，每个个体平等、自由，社会会以一种必然的不可阻挡的形态往前演进。</p> <p>回到前端发展历史，前面说了这么多，只说了一件事，前后端分层协作的各种模式。协作的边界是数据，后端提供数据服务接口，前端消费数据实现人机交互。不同模式下，BaaS（Backend as a Service）的含义各有不同。在 BFF 模式下，由于 BFF 层的运维部署需要，前端还需负责 BFF 层的 PaaS 平台建设。不同模式下的工程体系各有不同，工程的本质是让一群人做好一堆事，涉及代码规范、协作流程、运维部署、性能与安全等很多领域，这里不再一一展开。</p> <p>服务端 Node 与各种终端的涌现，让前端进入了大前端范畴，这时候的前端，已远远不只是浏览器端的页面实现技术，而是后端服务与人机界面的连接器。</p> <p><img src="//dn-cnode.qbox.me/Fgj5HsTiql9rambFQbhDg8t49tw3" alt="v2-374230208f31483237155e80d46f1c0d_hd.jpg"></p> <h2>什么是体验科技</h2> <p>我属于无线 ALL IN 战略中，选择留下来继续做 PC Web 的前端。虽然公司重点转向无线，但 PC 业务一直没停。随着近几年整个阿里集团“大中台、小前台”的策略，越来越多的企业级中后台产品处于兵荒马乱阶段，设计师非常缺失，随手一抓，都是大量体验比较糟心的产品。这过程中，越来越感觉什么地方有问题，一定在某些点上我们没做好。当时没多想，就想着既然缺设计师，我们就尝试去招聘。于是体验技术部开始拥有了设计师，非常艰辛的起步，非常感激的是，虽然艰辛，但找到了一些与我一样坚信中后台产品价值的设计师。一旦有了设计师，整个中后台产品的用户体验，一下子就提升上来了。</p> <p><img src="//dn-cnode.qbox.me/FvNAdF0m7cCZlevYQDFThuRYxvbz" alt="v2-54abf60cd133916e016343ae4adaf376_hd.jpg"></p> <p>设计团队的融入，日常的各种碰撞交流，让我的思维发生了很大变化。前端技术再牛，都很难直接解决产品层的用户体验。对中后台产品来说，设计的价值也远远不止于让产品的颜值提升，设计的更多更多价值，在于深入到产品的业务逻辑里去，去帮助业务梳理产品信息架构与任务流程。用户体验是一个非常综合的事，需要各种专业人士在同一个产品上聚焦发力，一起共同努力才能真正提升产品体验。设计师在这个过程中很痛苦，很多中后台产品都是非常垂直领域的业务产品，中间件、ECS、ODPS 等一堆堆专业术语让设计师们痛苦不堪，幸运的是，我们扛了过来。</p> <p><img src="//dn-cnode.qbox.me/Fk5n__QHurYmZawYh6-UXJ5Ox0Tv" alt="v2-9b693a1affab86f96e24e0bee03b3e90_hd.jpg"></p> <p>接下来的故事，在今天各个讲师的分享里，不少都有提及。整个团队的重心，开始非常清晰地往几个方向发展：</p> <ul> <li>TWA 方向：这是比 BFF 更大的概念，上午不四的分享里有详细阐述，可参考 知乎专栏文章 。TWA 是 Techless Web App 的缩写，是一种技术理念，希望越来越多的开发者，可以不用再关注流程、构建、环境、部署等各种事，希望能做到技术无感化（Techless），让每一位开发着能安安静静的快乐编码。</li> <li>UI 智能化方向：Ant Design 是一个设计体系，antd 是 Ant Design 的 React 实现。这几年 antd 的发展，不仅让前端编码更快更爽了，同时让一个历史悠久但生生不息的领域重燃希望：是否存在人机交互界面智能可视化搭建的可能？这个领域，这一两年在阿里内部非常火，各种搭建产品层出不穷，目前都还处于比较垂直的领域，泛化到行业级通用的产品还没怎么出现。我们也开始尝试，而且我们相信天时地利人和，一定能折腾出点什么，正在努力中，或许在下次 SEE Conf 大会中会展示给大家。</li> <li>数据可视化方向：下午绝云和御术的分享，相信大家对 G2 和 AntV 已经有了一个整体了解。可视化方向我们是从 2014 年开始正式投入人员去做，最开始的想法来自科幻片，大家如果喜欢看科幻片的话，会留意到各种人机交互界面都是各种可视化效果了，很少很少有传统网页。可视化是个历史非常悠久的领域，我们小学时学会的乘法竖式，就是一种可视化，可以帮助我们减少记忆成本，同时提升计算速度。</li> <li>图形互动化方向： 上午好修和景夫有分享，这一块才开始一年多，是我们非常笃定的一个方向。很多小孩，对书本都比较抗拒，但对游戏有着天生的喜爱。蚂蚁森林让大家从表单形式的公益，变成了互动游戏型的公益。越来越多的人机交互形式，会是有互动交互的图形界面。应用的泛互动化，是一个很大趋势。支付宝是个生活服务平台，各种生活服务的互动有趣化，一定是更有吸引力的。</li> </ul> <p><img src="//dn-cnode.qbox.me/Fui53ymFhJc0JS0IA0ZXqUvBNFiQ" alt="v2-6830ebf2ca603dca8bd33723d73220e3_hd.jpg"></p> <p>看更远的未来，我相信对体验科技来说，自然化和虚拟化会是两个大趋势。</p> <p>我现在在分享这个 PPT，要翻页时，需要点击键盘按钮，为什么电脑不能直接理解我的意图而自动翻页呢？比如我只要头往下示意一下，就能自然而然翻到下一页。我们现在很多行为，跳脱出来看，能发现很多很多不自然。天猫精灵等各种智能音箱，真正去用时，离自然交互还有比较远的距离。Ant Design 设计价值观里，最最重要的就是自然价值观，一切才刚刚开始探索。</p> <p>再说虚拟化。虚拟化不仅仅指 AR、VR 等技术，看过黑客帝国、西部世界等科幻片的，会对虚拟化有更多体感。如果以后每个小孩出生时，就会被植入一个能五感俱全的芯片，这种情况下，我们的人机交互会是怎么样的。太多可能性与挑战在等着我们。</p> <p>这一切都是体验科技，是技术与设计的融合，是服务与用户连接，是下图中的一个公式。</p> <p><img src="//dn-cnode.qbox.me/Fh5rgc3RVIRYuQYZSXMdKlBKlfnB" alt="v2-773def061a6dd38cd97c52f040da29cc_hd.jpg"></p> <p><img src="//dn-cnode.qbox.me/FpueJ6H7sBiB7kVsLORMYQpjDClK" alt="v2-e4186cd37a1f978abbf64970dee50ba9_hd.jpg"></p> <p>体验科技是 UX = f(services) 这个公式，能将各种各种的 services（后端服务） 通过技术与设计的融合，转变成体验一流的用户产品。这个公式的一个实现，就是蚂蚁体验云。蚂蚁体验云的初心，是希望能帮助有梦想的你，将一个个优秀的想法，通过体验云实现成一个个终端产品。 <img src="//dn-cnode.qbox.me/FjtnnNqNeyh5rH4MTreunWUgsNgj" alt="v2-ab3eae986630f436d1c6b751f4a8d895_hd.jpg"></p> <p>体验云才刚刚起步，目前已在内部服务蚂蚁金服、阿里巴巴集团，同时快速孵化出了云凤蝶、语雀、小钱袋等创新产品。虽然还很不完善，但我们希望能尽快与用户一起成长。很多激动人心的事正在发生，通过体验科技的开放，我们希望着能为世界带来更多平等的机会。 <img src="//dn-cnode.qbox.me/FgGx0MFi9k0eJAeLX3icMz6YLD9v" alt="v2-98323a7d1c563df55151451066a7709e_hd.jpg"></p> <p>感谢聆听，期待交流。</p> <p>附 SEE Conf 演讲视频： <a href="http://v.youku.com/v_show/id_XMzMwMzg2MDIwOA==.html">优酷地址 </a></p> <p>最后，演讲 PPT 已精心整理并转换为 PDF 上传至<a href="http://yuque.com/seeconf"> SEE Conf 语雀在线知识库</a>，欢迎下载（请 注册语雀，个人描述内注明 #知乎seeconf# 便可快速申请邀请码，登录后即可下载）</p> </div>",
title: "玉伯《从前端技术到体验科技（附演讲视频）》",
last_reply_at: "2018-01-17T14:30:58.022Z",
good: false,
top: true,
reply_count: 14,
visit_count: 4077,
create_at: "2018-01-09T11:33:56.183Z",
author: - {
loginname: "i5ting",
avatar_url: "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    },
- {
id: "592917b59e32cc84569a7458",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p> <p>以下情况，直接封号</p> <ul> <li>测试标题</li> <li>无任何内容</li> <li>无意义回复</li> <li>测试帖，5分钟内没有删除</li> </ul> <p>欢迎大家监督</p> <p>封号</p> <ul> <li><a href="https: //cnodejs.org/user/Mwangzhi">https://cnodejs.org/user/Mwangzhi</a></li> <li><a href="https://cnodejs.org/user/lw6395">https://cnodejs.org/user/lw6395</a></li> <li><a href="https://cnodejs.org/user/shengliang74">https://cnodejs.org/user/shengliang74</a> 竟然挑衅，发帖说你来打我呀。。。。</li> <li><a href="https://cnodejs.org/user/h5-17">https://cnodejs.org/user/h5-17</a> <a href="/user/h5-17">@h5-17</a></li> <li><a href="https://cnodejs.org/user/592php">https://cnodejs.org/user/592php</a> <a href="/user/592php">@592php</a></li> </ul> <hr> <p>20170601更新</p> <p><a href="https://cnodejs.org/?tab=dev">https://cnodejs.org/?tab=dev</a> 目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p> <p><img src="//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-" alt="image.png"></p> </div>",
title: "测试请发到客户端测试专区，违规影响用户的，直接封号",
last_reply_at: "2018-01-03T15:43:22.119Z",
good: false,
top: true,
reply_count: 147,
visit_count: 36374,
create_at: "2017-05-27T06:07:49.278Z",
author: - {
loginname: "i5ting",
avatar_url: "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    },
- {
id: "5a6335bbafa0a121784a8dfe",
author_id: "592ee9eaba8670562a40f6a4",
tab: "ask",
content: "<div class="markdown-text"><p>使用ng build --prod 打包时，报错：</p> <p><img src=" //dn-cnode.qbox.me/Fm55A-SLhNqpbq9_Kr1K2t7xb7eu" alt="1.PNG"></p> <p><img src="//dn-cnode.qbox.me/FmzDyxE2hOtj3rNnBN8h_O4EnuNy" alt="2.PNG"></p> <p>下面是开发环境：</p> <p><img src="//dn-cnode.qbox.me/Fgs-5ZN_coGiiEUOuTd4XnHfiY8V" alt="ng-version.PNG"></p> <p>求教大佬们，怎么解决啊？</p> <p>有升级过angular-cli，还是同样状况。</p> </div>",
title: "angular4 打包问题",
last_reply_at: "2018-01-22T08:51:20.365Z",
good: false,
top: false,
reply_count: 4,
visit_count: 207,
create_at: "2018-01-20T12:27:39.849Z",
author: - {
loginname: "hesen1",
avatar_url: "https://avatars0.githubusercontent.com/u/20394832?v=4&s=120"
        }
    },
- {
id: "5a55617299d207fa49f5cd85",
author_id: "5a3075929807389a1809f330",
tab: "ask",
content: "<div class="markdown-text"><p>请不要百度出来的东西复制给我，， 百度了半天。。 有说是有白名单的，不知道哪里申请。。</p> </div>",
title: "微信、QQ上页面，video 标签如何不默认全屏？有没有搞过的，实在没辙了",
last_reply_at: "2018-01-22T08:36:29.027Z",
good: false,
top: false,
reply_count: 9,
visit_count: 662,
create_at: "2018-01-10T00:42:26.478Z",
author: - {
loginname: "varwx",
avatar_url: "https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"
        }
    },
- {
id: "5a653da29d371d4a059eecbd",
author_id: "5a3075929807389a1809f330",
tab: "ask",
content: "<div class="markdown-text"><p>点餐类的，单商户的，业务暂时不复杂 node不能做商城么？为什么有人这么说</p> </div>",
title: "商城用哪些框架比较适合呢？点餐类的",
last_reply_at: "2018-01-22T08:32:48.884Z",
good: false,
top: false,
reply_count: 7,
visit_count: 228,
create_at: "2018-01-22T01:25:54.544Z",
author: - {
loginname: "varwx",
avatar_url: "https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"
        }
    },
- {
id: "5a5b7638a3692d014f4f146e",
author_id: "59603478a4de5625080fe1cd",
tab: "ask",
content: "<div class="markdown-text"><p>急急急！！！ 最近正在需node.js 想找一个基于express mongodb 前后端分离的项目 瞅瞅代码 看看大牛的 思路 和代码顺序 求推荐</p> </div>",
title: "急求node.js案例！！！",
last_reply_at: "2018-01-22T08:20:20.896Z",
good: false,
top: false,
reply_count: 7,
visit_count: 892,
create_at: "2018-01-14T15:24:40.422Z",
author: - {
loginname: "xiaoyu311",
avatar_url: "https://avatars3.githubusercontent.com/u/29394664?v=4&s=120"
        }
    },
- {
id: "5a659e00ce45d44045146233",
author_id: "5a12ccc1f3f26b2c61ac53af",
tab: "ask",
content: "<div class="markdown-text"><pre class="prettyprint"><code>app.use(expressSession({ resave: true,// 强制更新 session saveUninitialized: false,// 设置为 false，强制创建一个 session，即使用户未登录 secret: 'session-cookie', store: new MongoStore({// 将 session 存储到 mongodb url: 'mongodb://localhost:27017/session-cookie'// mongodb 地址 }), cookie: {maxAge: 1000 * 60 * 60} })); </code></pre><p>关闭浏览器后重新打开还是呈现登录状态，是缓存的原因吗？ 理论上 cookie 存放在浏览器内存中，关闭浏览器以后 cookie 就消失了</p> <p>一开始的实验也验证了这个理论，重复多次后就出现相反的现象（关闭浏览器后重新打开还是呈现登录状态），是缓存吗？</p> </div>",
title: "express-session 关闭浏览器后重新打开还是呈现登录状态",
last_reply_at: "2018-01-22T08:17:04.238Z",
good: false,
top: false,
reply_count: 0,
visit_count: 21,
create_at: "2018-01-22T08:17:04.238Z",
author: - {
loginname: "zengj8",
avatar_url: "https://avatars3.githubusercontent.com/u/26499655?v=4&s=120"
        }
    },
- {
id: "5a659dc5afa0a121784a8e6f",
author_id: "570f751f400ca111729e884b",
tab: "share",
content: "<div class="markdown-text"><p>在vue移动端开发中，vux是一个比较好的UI模板，这个项目集成了vux，并在webpack中做了一些优化，避免开发过程中出现版本依赖，热更新出错更奇怪的问题，可以当作各种项目的一个空白模板 <a href="https: //github.com/jinghaonode/vue-vux-demo">https://github.com/jinghaonode/vue-vux-demo</a></p> </div>",
title: "分享一个Vue+vux好用的空白项目模板",
last_reply_at: "2018-01-22T08:16:05.805Z",
good: false,
top: false,
reply_count: 0,
visit_count: 32,
create_at: "2018-01-22T08:16:05.804Z",
author: - {
loginname: "jinghaonode",
avatar_url: "https://avatars0.githubusercontent.com/u/12907388?v=4&s=120"
        }
    },
- {
id: "5a637604ce45d440451461c5",
author_id: "5a5c03aca3692d014f4f1472",
tab: "ask",
content: "<div class="markdown-text"><p>比如,在一个file.js里面, 引入fs模块 然后, 其中的一个函数中有一条语句是 fs.readdir(“某一个路径”,(err, files)=>{</p> <p>});</p> <p>然后其他的文件调用这个文件,比如入口文件调用这个文件file.js 在index.js中写到</p> <p>var file = require("./models/file.js"); 调用: file.上面友fs.readdir语句的函数, 那么, Nodejs自带的模块,路径是相对于运行时,还是引入的时候?</p> </div>",
title: "Nodejs自带的模块,路径是相对于运行时,还是引入的时候?",
last_reply_at: "2018-01-22T08:05:33.223Z",
good: false,
top: false,
reply_count: 9,
visit_count: 245,
create_at: "2018-01-20T17:01:56.637Z",
author: - {
loginname: "AmandaYi",
avatar_url: "https://avatars1.githubusercontent.com/u/23202919?v=4&s=120"
        }
    },
- {
id: "5a5c8d2eafa0a121784a8c05",
author_id: "536b0ab9c077d1b33302ad05",
tab: "ask",
content: "<div class="markdown-text"><p>小弟现在在开发一个内部系统，是基于 Nodejs 的，因为本人后端经验不足，请求大家帮助。</p> <p>需求是：现在调用一个接口，这个接口会调用一个 npm 模块，这个模块是一个异步的。</p> <p>问题：</p> <ol> <li>我怎么调用这个 npm 模块</li> <li>并且在调用任务完成后知道已经完成</li> </ol> <p>如果上述问题解决了，怎么如何保证同时调用调用这个服务不冲突呢。</p> <p>希望大家不吝赐教。</p> </div>",
title: "Node 怎么调用服务?",
last_reply_at: "2018-01-22T08:00:50.806Z",
good: false,
top: false,
reply_count: 12,
visit_count: 666,
create_at: "2018-01-15T11:14:54.548Z",
author: - {
loginname: "riskers",
avatar_url: "https://avatars3.githubusercontent.com/u/5653652?v=4&s=120"
        }
    },
- {
id: "5a62125cce45d44045146198",
author_id: "576a5d4063075514079b77e7",
tab: "ask",
content: "<div class="markdown-text"><p>在我的个人博客后台系统，去拉取文章列表的时候，由于返回的document 有几百k, 足足用了10s. 单个文章的document 也有可能上百kb。这种情况下，mongodb有什么相应的优化或提高性能的办法么。是否可以通过document gzip 处理？ <img src=" //dn-cnode.qbox.me/FklKhLppqDayll1QP8f5I7ekAHb-" alt="WechatIMG449.jpeg"></p> </div>",
title: "mongodb 几百kb document 请求返回过慢优化",
last_reply_at: "2018-01-22T07:38:01.451Z",
good: false,
top: false,
reply_count: 5,
visit_count: 247,
create_at: "2018-01-19T15:44:28.295Z",
author: - {
loginname: "MaelWeb",
avatar_url: "https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"
        }
    },
- {
id: "5a61ad4ece45d44045146172",
author_id: "59c464898812ce51127a90e4",
tab: "ask",
content: "<div class="markdown-text"><p>node Server 开启，server 可能因为各种各样的问题异常退出，虽然我能够通过线程监控手段让Server在短时间内起死回生，但Server死之前的那些用户请求附带繁杂的数据库请求以及文件请求怎么处理？</p> </div>",
title: "【新手提问】关于node经常挂掉，数据库怎么办",
last_reply_at: "2018-01-22T07:36:46.888Z",
good: false,
top: false,
reply_count: 14,
visit_count: 400,
create_at: "2018-01-19T08:33:18.508Z",
author: - {
loginname: "Monisuy",
avatar_url: "https://avatars2.githubusercontent.com/u/25356455?v=4&s=120"
        }
    },
- {
id: "59c0d4038812ce51127a8fe5",
author_id: "581378c0cf18d0333412d2a2",
tab: "ask",
content: "<div class="markdown-text"><p><strong>问题：</strong></p> <p>表单里面有base64 位的图片数据 ， 在express server 端就会接收不到。该如何解决？</p> </div>",
title: "nodejs express 在提交的表单中含有比较大的base64位图片数据，服务端接收不到，该怎么做？",
last_reply_at: "2018-01-22T07:33:05.907Z",
good: false,
top: false,
reply_count: 4,
visit_count: 761,
create_at: "2017-09-19T08:23:31.008Z",
author: - {
loginname: "spursy",
avatar_url: "https://avatars0.githubusercontent.com/u/11460991?v=4&s=120"
        }
    },
- {
id: "5a4db120ebc575dc49b27108",
author_id: "547c35030ae47dec03aa2939",
tab: "share",
content: "<div class="markdown-text"><p><img src="http: //upload-images.jianshu.io/upload_images/145564-060eef2e34e2dcfd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue's templates&amp;react'JSX"></p> <p><strong>React.js</strong>和<strong>Vue.js</strong>是这个星球上最流行的<strong>JavaScript</strong>库。它们都很强大，相对来说很容易获取和使用。</p> <p><strong>React</strong>和<strong>Vue</strong>的共性：</p> <ol> <li> <p>使用虚拟DOM。</p> </li> <li> <p>提供响应式视图组件。</p> </li> <li> <p>专注于开发过程中的一个方面。目前集中在视图层。</p> </li> </ol> <p>有这么多相似之处，你可以假设它们都是同一事物的不同版本。</p> <p>这两个库之间有一个主要的区别：它们如何让开发人员创建视图组件，反过来又可以应用程序。</p> <p>React采用<strong>JSX</strong>（这个词是react团队创造的）渲染内容到<strong>DOM</strong>。那么什么是JSX？基本上，JSX是一个JavaScript渲染功能，帮助你将你的HTML放到你的JavaScript代码中合适的地方。</p> <p>Vue采用不同的方法，使用HTML模板。使用Vue模板就像是用JSX就是他们都是创建使用JavaScript。主要的区别是，JSX函数在实际的HTML文件中从来不被使用，而Vue模板不是这样。</p> <p>特别说明下，Vue.js的相关课程可以<a href="http://www.hubwiz.com/course/?type=vue.js&affid=cnodejs">点击这里。</a></p> <h1>React JSX</h1> <p>我们将深入探讨JSX如何工作。假设你有一个要在DOM上显示的名称列表。你们公司最近的一份新员工名单。</p> <p>如果你使用的是普通的<strong>HTML</strong>，你首先需要创建一个index.html文件。然后，你将添加以下代码行。</p> <pre class="prettyprint"><code><ul> <li> John </li> <li> Sarah </li> <li> Kevin </li> <li> Alice </li> <ul> </pre> </code></pre><p>这里没什么好说的，只是普通的<strong>HTML</strong>代码。</p> <p>那么你使用<strong>JSX</strong>怎么做同样的事情？第一步是创建一个index.html文件。但是，不像以前那样添加完整的HTML，只需要添加一个简单的<strong>div</strong>元素。这个<strong>div</strong>将是容器元素，在那里您的所有<strong>React</strong>代码将被呈现。</p> <p>div将需要一个唯一的ID，这样React就知道如何可以找到它。facebook倾向于支持根关键字，所以让我们坚持这一点。</p> <pre class="prettyprint"><code><div id=root></div> </code></pre><p>现在，走到最重要的一步。创建包含所有react代码的JavaScript文件。这是一个叫app.js的文件。</p> <p>你现在把所有的事情都排除在外，进入主事件。用JSX显示所有新员工到 DOM中。</p> <p>首先需要创建一个具有新雇员名称的数组。</p> <pre class="prettyprint"><code>const names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’]; </code></pre><p>从那里，您需要创建一个响应元素，它将动态地呈现整个名称列表。这你没有必要再手动显示每一个。</p> <pre class="prettyprint"><code><ul> {names.map(name => <li>{name}</li> )} </ul> ); </code></pre><p>这里要注意的关键是，您不必创建单独的**<li><strong>元素。你只需要描述你想让他们看一次，React会处理剩下的。这是一件非常给力的事。虽然你只有几个名字，但想象一下有成百上千的名单！你可以看到这当然是一个更好的方法。特别是如果</strong><li>**元素，比这里用到的元素更复杂。</p> <p>代码的最后一步是需要将内容渲染到屏幕，主要是通过<strong>ReactDom</strong>的<strong>render</strong>渲染函数。</p> <pre class="prettyprint"><code>ReactDOM.render( displayNewHires, document.getElementById(‘root’) ); </code></pre><p>在这里，你在用div里的内容作出响应，通过<strong>displayNewHires</strong>渲染<strong>root</strong>元素。</p> <p>那么最终的React代码就应该是这个样子：</p> <pre class="prettyprint"><code>const names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’]; const displayNewHires = ( <ul> {names.map(name => <li>{name}</li> )} </ul> ); ReactDOM.render( displayNewHires, document.getElementById(‘root’) ); </code></pre><p>这里要记住的一个关键是，这是所有的React代码。这意味着它都将编译成普通的JavaScript。下面是它最终看起来的样子：</p> <pre class="prettyprint"><code>‘use strict’; var names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’]; var displayNewHires = React.createElement( ‘ul’, null, names.map(function (name) {  return React.createElement(  ‘li’,  null,  name  ); }) ); ReactDOM.render(displayNewHires, document.getElementById(‘root’)); </code></pre><p>这就是它的全部。现在有一个简单的React应用程序，它将显示名称列表。没有什么可以写的，但它应该能让你了解React的能力是什么。</p> <p>特别说明下，react.js的相关课程可以<a href="http://www.hubwiz.com/course/?type=react&affid=cnodejs">点击这里。</a></p> <h1>Vue.js Templates（模板）</h1> <p>按照最后一个示例，您将再次创建一个简单的应用程序，它将在浏览器上显示名称列表。</p> <p>你需要做的第一件事就是创建一个空的index.html文件。在该文件中，您将创建一个带有根ID的空<strong>div</strong>。记住，根只是个人偏好。你可以调用你的ID无论什么情况下。您只需确保稍后将HTML与JavaScript代码同步时匹配起来即可。</p> <p>这个div会像它在React中那样起作用。它会告诉JavaScript库，在这个示例中，开始改变的时候在哪里观察DOM。</p> <p>一旦这样做了，你将创建一个JavaScript文件，将存放Vue代码。称它为app.js，以便保持一致。</p> <p>现在你已经准备好你的文件，让我们看看Vue如何显示元素到浏览器。</p> <p>Vue使用模板的方法用它来操作DOM。这意味着你的HTML文件不仅会有一个空的div，比如在React中。实际上，您将在HTML文件中编写一部分代码。</p> <p>为了给你一个更好的提醒，回想一下使用普通HTML创建名称列表需要什么。一个**<ul><strong>包含一些的</strong><li>**元素。在Vue，你要做几乎相同的事情，只有少数的变化增加。</p> <p>创建一个**<ul>**。</p> <pre class="prettyprint"><code><ul> </ul> </code></pre><p>现在添加一个空的**<li>**。</p> <pre class="prettyprint"><code><ul> <li> </li> </ul> </code></pre><p>没什么新鲜的变化，通过增加一个指令，一个自定义的Vue的属性你的**<li>**元素。</p> <pre class="prettyprint"><code><ul> <li v-for=’name in listOfNames’> </li> </ul> </code></pre><p>指令是Vue直接进入HTML添加JavaScript功能的方式。它们都以V开头，后面跟着描述性的名字，让你知道他们在做什么。在这个实例中，它是for循环。每一个名字在你的名字列表listOfNames中，你可以从你的名单列表上复制这个<li>元素和更换一个新的<li>元素来确定一个的名字。</p> <p>现在，代码只需要最后一次编写。当前，它将为列表中的显示每个名称，但实际上并没有告诉它将把实际名称显示在浏览器上。为了解决这个问题，你将在你的<li>中插入一些类似<strong>mustache</strong>的语法。你可能在其他JavaScript库中看到的类似东西。</p> <pre class="prettyprint"><code><ul> <li v-for=’name in listOfNames’> {{name}} </li> </ul> </code></pre><p>现在<li> 元素是写完了。它现在将显示名字为listOfNames列表的每个项。记住name可以是任何其他的名称。你可以把它叫做item，它也会达到同样的目的。所有关键字都用作占位符，用于在列表中迭代。</p> <p>你需要做的最后一件事就是创建数据集和在实际应用程序中初始化Vue。</p> <p>这样做，你将需要创建一个新的Vue实例。通过将它分配给名为app的变量来实例化它。</p> <pre class="prettyprint"><code>let app = new Vue({ }); </code></pre><p>现在，对象将包含一些参数。第一个是最重要的，<strong>el</strong> (element) 参数告诉Vue在DOM开始添加什么内容。就像你对你的React中的例子那样。</p> <pre class="prettyprint"><code>let app = new Vue({ el:’#root’, }); </code></pre><p>最后一步是添加数据到Vue的应用。在Vue，所有的数据都将做为Vue实例的参数传送到应用程序。另外，每个Vue实例只能有一个每种类型参数。虽然有相当多的，但您只需要集中在两个例子，<strong>el</strong>和<strong>data</strong>。</p> <pre class="prettyprint"><code>let app = new Vue({ el:’#root’, data: { listOfNames: [‘Kevin’, ‘John’, ‘Sarah’, ‘Alice’] } }); </code></pre><p>数据对象将接受一个数组<strong>listOfNames</strong>。现在，每当您想在应用程序中使用该数据集时，只需要使用指令调用它。很简单，对吧？</p> <p>这是最终的代码：</p> <h1>HTML</h1> <pre class="prettyprint"><code><div id=”root”> <ul> <li v-for=’name in listOfNames’> {{name}} </li> </ul> </div> </code></pre><h1>JavaScript</h1> <pre class="prettyprint"><code>new Vue({ el:”#root”, data: { listOfNames: [‘Kevin’, ‘John’, ‘Sarah’, ‘Alice’] } }); </code></pre><h1>结论</h1> <p>现在你知道如何使用React和Vue创建两个简单的应用程序。他们都提供了强大的功能，虽然Vue看起来往往是更容易使用。还有需要记住，Vue也支持JSX的使用，虽然它不是首选的实现方法。</p> <p>无论哪种方式，Vue和React都是两个功能强大的库，你使用任何一个都不会有问题。</p> <p>如果你觉得这篇文章很有帮助，给我一些掌声。</p> <p>你可以在Twitter上跟踪我！</p> <p>汇智网（<a href="http://www.hubwiz.com/course/?type=vue.js&affid=cnodejs">www.hubwiz.com</a>，有很多很棒vue.js的课程包括vue.js\vuex\vue-router\vue工程化等）的小智原创翻译。</p> </div>",
title: "前端的对决：React的JSX与Vue的templates",
last_reply_at: "2018-01-22T07:32:05.559Z",
good: false,
top: false,
reply_count: 15,
visit_count: 1233,
create_at: "2018-01-04T04:44:16.207Z",
author: - {
loginname: "2596887568",
avatar_url: "https://avatars3.githubusercontent.com/u/9349200?v=4&s=120"
        }
    },
- {
id: "5a61870c9288dc8153287f8c",
author_id: "5762e8fefa83165906ace41e",
tab: "ask",
content: "<div class="markdown-text"><p>描述： pm2来定时执行一个邮件发送程序，如果程序是通过process.exit来退出的，就无法重新启动。而如果是正常退出的则能定时启动 <code>ecosystem.json</code>配置如下:</p> <pre class="prettyprint"><code>{ "apps": [{ "name": "index", "script": "index.js", "error_file": "err.log", "out_file": "out.log", "merge_logs": true, "log_date_format": "YYYY-MM-DD HH:mm Z", "min_uptime": 100, "cron_restart": "* * * * *", "autorestart": false } ] } </code></pre></div>",
title: "请问，pm2定时任务未能重启",
last_reply_at: "2018-01-22T07:22:52.127Z",
good: false,
top: false,
reply_count: 1,
visit_count: 198,
create_at: "2018-01-19T05:50:04.701Z",
author: - {
loginname: "idsaynever",
avatar_url: "https://avatars1.githubusercontent.com/u/30641746?v=4&s=120"
        }
    },
- {
id: "5a630c649288dc8153287fe4",
author_id: "56ce68bc842c03521a73520e",
tab: "ask",
content: "<div class="markdown-text"><p>查询要求如下：</p> <ol> <li>搜索标签字段（数组类型，形如tag:[“好看”,“大气”,“高个子”]），如果用户输入了搜索条件就按条件搜索，如果没输入就搜索返回所有数据</li> <li>不准用$OR（这里简化了真实场景，真实场景中无法用$or）</li> <li>数据库中用户名字段，存在空值</li> </ol> </div>",
title: "请教一条mongodb查询语句",
last_reply_at: "2018-01-22T07:21:42.124Z",
good: false,
top: false,
reply_count: 3,
visit_count: 201,
create_at: "2018-01-20T09:31:16.384Z",
author: - {
loginname: "qujinxiong",
avatar_url: "https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"
        }
    },
- {
id: "5a6010e19d371d4a059eebd2",
author_id: "5a5d5e809288dc8153287e4f",
tab: "share",
content: "<div class="markdown-text"><p>什么 Java Python… 未来是nodejs的！</p> <blockquote> <blockquote> <p>What? Why? << Simple !!!</p> </blockquote> <blockquote> <p>Only Simple? << It’s enough.</p> </blockquote> </blockquote> </div>",
title: "nodejs称霸一切 :)",
last_reply_at: "2018-01-22T07:18:56.523Z",
good: false,
top: false,
reply_count: 16,
visit_count: 1104,
create_at: "2018-01-18T03:13:37.139Z",
author: - {
loginname: "baofengyv",
avatar_url: "https://avatars3.githubusercontent.com/u/5669938?v=4&s=120"
        }
    },
- {
id: "5a61e5d8afa0a121784a8dc4",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><h1>我的2017年总结</h1> <p>在知乎上，我回复了《coding到没脾气的时候，你一般都会干什么？》<a href="https: //www.zhihu.com/question/264015952/answer/278283535">https://www.zhihu.com/question/264015952/answer/278283535</a> 这个问题。答案如下</p> <p>“【不扯淡】年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p> <p>工程师的能力不是编码和死磕，而是解决问题</p> <p>很多人点赞，就说的再明白点</p> <ul> <li>年轻死磕是为了长本事，30岁以前都可以这样做</li> <li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li> <li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li> </ul> <p>少抱怨，多思考，未来更美好</p> <p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。”</p> <p>这其实是我这1年一个非常大的变化。想明白了很多事，心态上好了很多。另外，作为网红的好处的是你能够接触到<strong>更多信息和更好的朋友圈子</strong>。这其实是以前没法做到的。我本身也是偏于内向的人，只是不得已做公众号，演讲，布道，应酬，收获当然也是相当丰富的。以前看事情是<strong>点</strong>，现在看的是<strong>趋势</strong>，能够做到心中有数，自然胸有成竹的感觉。</p> <blockquote> <p>淡然，自省，大概是个比较好的状态。</p> </blockquote> <p>2017年年初儿子出生，银川没有合适工作，不得已，去了去哪儿工作，这也是个艰难的选择。之后去了得到，现在在阿里巴巴，关于工作的个中曲折后面会讲。在qunar的时候比较闲，跟着莫子（付洪波）老师练了半年多的形意拳，后来被方圆和timyang等老司机影响，也开始学习摄影。其实书法，诗歌，摄影类的艺术来说是有共性的，希望自己能够坚持下去。</p> <p>在个人品牌方面，这1年时间做了很多场500+人得演讲，写了很多精华文章，单篇最高超过9万阅读量。Node全栈公众号超过1.8万粉丝，我的个人知乎半年时间粉丝超过2200人（之前没玩过，感谢justjavac大神带路），组织了几次活动，也算是不错的尝试，可以接触到更多的Node.js相关的高手和各种需求，解决方案，对我的知识面是有很大提升的。另外，从qunar到阿里巴巴大厂摸爬滚打，也是学到很多东西，大厂是有很多有内涵的东西的，当然这要靠自己挖掘。同时，建立了个人网站 <a href="http://i5ting.com">i5ting.com</a>，目前东西还比较少，但至少起步了。</p> <p>在2017年，完成了2本书：《更了不起的Node.js》和个人诗集《春天的恐惧症》。更了不起的Node.js拖了2年了，从Node 4写到node9了，过程是痛苦极了的，其实这2年对我的成长也是极大的，大部分时间都是在构建我个人的知识体系。本书“了不起”就是个很难讲的，要讲清楚“更了不起”就是件更难的事儿！好在node在最近2年应用场景等方面有了更广更好的应用，自身知识体系加上qunar和阿里巴巴的经验，能完成也是不容易的，换工作也是有好处的。目前2本书都交给编辑了，应该很快可以面世了。</p> <p>儿子已经一岁了，我媳妇把孩子照顾的非常好，健康，活泼可爱。这一年，我往返北京和银川太多次了。以前在quanr的时候，我没有租房，几乎每周末都回家。宝宝还没出生，我就到北京上班了，在qunar工作的那段时间里，我是最嚣张的，请了好多假。每周五晚上回银川，周日晚上回北京，卧铺车厢无情的空调，吹得我中风几次。可是，还是要回家。老婆孩子都在地方，才是家。最难过的是周一到周五，只能看媳妇通过微信发来宝宝的视频，一遍一遍的看，一遍一遍的想哭。</p> <pre class="prettyprint"><code>媳妇发来宝宝的视频 媳妇发来宝宝的视频 只有九秒，一遍一遍的看 宝宝二个月了 已经会吃衣袖了 媳妇发来宝宝的的视频 只有九秒，既短又长 已经有六天没有见到了 愈加想念 他不会说话，只会哭喊 他不会动，虽然很想动 他不乖，除了吃奶的时候 他还不能陪爸爸一起玩 媳妇发来宝宝的视频 只有九秒，一遍一遍的看 一路上，一遍一遍的看 一遍一遍的想笑，想哭。。。 “路人一定都觉得爸爸是个可爱的神经病” </code></pre><h2>关于工作</h2> <ul> <li>Qunar机票</li> <li>得到，呆了7周</li> <li>阿里巴巴大文娱</li> </ul> <p>很多人在网上黑我，说我换工作比较多。当然这是事实，但也要不至于如何如何吧。</p> <p>Qunar的管理和公司流程做的非常好，其内部被携程合并之后能做的事儿并不多。其实在qunar做的事儿是比较少得，大部分时间都在往返北京和银川的路上。在qunar，我做了3件事儿</p> <ul> <li>组织和饿了么北研的一次活动。活动大部分都是我和我朋友帮忙弄得，甘苦自知吧。从海报，文章，到演讲主题，到行程，每个细节都要自己做。</li> <li>做了bigview，已开源，主要是bigpipe实现的框架。在qunar没太多存在感，所以也懒得去推。后面会持续投入，在Node.js做api中间件层，此框架是利器。</li> <li>促成了hiproxy的成长。代应（<a href="https://github.com/zdying%EF%BC%89%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%EF%BC%8C%E6%9C%89%E6%83%B3%E6%B3%95%E6%9C%89%E6%89%A7%E8%A1%8C%E5%8A%9B%EF%BC%8Cqunar%E5%86%85%E9%83%A8%E5%A4%A7%E9%87%8F%E4%BE%9D%E8%B5%96multi-hosts%E5%92%8Cnginx%EF%BC%8C%E5%88%87%E6%8D%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B2%9F%E9%80%9A%E6%88%90%E6%9C%AC%E9%9D%9E%E5%B8%B8%E5%A4%A7%EF%BC%8C%E4%BA%8E%E6%98%AF%E4%BF%83%E6%88%90%E4%BA%86%E4%BB%96%E4%BB%AC%E7%9A%84%E8%9E%8D%E5%90%88%EF%BC%8C%E5%8D%B3%E4%BD%BF%E7%94%A8hiproxy%E5%8F%AF%E4%BB%A5%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E3%80%82">https://github.com/zdying）是非常不错的小伙伴，有想法有执行力，qunar内部大量依赖multi-hosts和nginx，切换项目的沟通成本非常大，于是促成了他们的融合，即使用hiproxy可以完美解决。</a> <a href="https://github.com/hiproxy/hiproxy">https://github.com/hiproxy/hiproxy</a></li> </ul> <p>从qunar离职后，我去了得到，罗胖的公司。知识付费领域做的相当好的品牌。最有希望的独角兽，我以为自己能够在里面做出点成绩，我对罗辑思维的评价</p> <ul> <li>品控做的确实好，所有产品公司里确实牛逼，打磨一个课程能够如此用心，真是难得。编辑工作做的也极好，对于错字，典故等也审核极其严格。</li> <li>产品细节做的也不错，快刀青衣对产品的把握感觉非常好，如果没想清楚，宁可不加，这在某种程度上，保证里app的简洁。</li> </ul> <p>但是一个快速增长的公司必然面临扩张期的阵痛，老的项目一堆，新招一堆高手也不会立马奏效。面临的都是两难选择，之前的东西不想碰，自己擅长的又用不上，真是很尴尬。之前我以首席架构师进去的，但没法在架构上做改进，很多东西不是一个人能搞定的。另外业务发展太快就导致管理跟不上，天天各种需求追的要命，还要兼顾团队建设，这事情哪能鱼和熊掌兼得呢。</p> <p>我对自己的定位是专注于Node.js技术，既然没法做更多Node.js相关的内容，不如就离开。</p> <p>我个人挺喜欢快刀的做事风格，也可怜他的处境。我也创过业，也激情过。我特别理解他的想法。他选了个好方向，罗胖和脱不花也确实是在各自领域做的不错，祝福吧。</p> <p>之后，我去了阿里巴巴大文娱，就是之前的老优酷，技术名声以前是不太好的。但好在被阿里收购1年多得时间，基本都改成阿里基因了。我进入的时间还好，老板也很信任，交给我很多我很有干劲的工作。比如h5播放器，之前很多人都没搞定，把一个极其传统的代码改成一个时髦的开发方式，使用babel，webpack，做了单元测试和端到端测试，采用模块化和面向对象，架构做的我觉得还不错。我能感觉到团队的变化，我很高兴的。当然，我对大家也是比较狠的，每天review代码到很晚，每个细节都会抠，每天回家都非常玩，大家其实状态还不错，解决了以前的困扰，在技术能力上也有提升，最重要的是有成就感，原来这样写代码，大家都可以的。这种带团队的过程对我来说也是非常有成就感的。当播放器成熟，内部稳定后，通过公司审批后，也会走开源之路，也希望给公司的技术影响力做一些贡献。</p> <p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p> <p>钱多是个优势而已，还有氛围，文化，信仰</p> <ul> <li>牛人多</li> <li>业务需要</li> <li>成熟后有更多精力</li> <li>内部竞争，优胜劣汰</li> <li>财务相对自由，可以追求信仰了</li> </ul> <p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p> <blockquote> <p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p> </blockquote> <p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p> <p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href="mailto:langshu.ssl@alibaba-inc.com">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p> <h2>关于《更了不起的Node.js》一书</h2> <p>节选部分和目录，让大家先睹为快。</p> <p>Node.js 简介</p> <p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href="https://github.com/ry">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p> <p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p> <p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p> <blockquote> <p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p> </blockquote> <p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href="https://www.taobao.com/">淘宝</a> 双十一、<a href="https://www.qunar.com/">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href="https://github.com/webpack/webpack">Webpack</a> 是一个强大的打包器，<a href="https://github.com/facebook/react">React</a>/<a href="https://github.com/vuejs/vue">Vue</a> 是成熟的前端组件化框架。</p> <p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p> <p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p> <p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href="http://fibjs.org/">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p> <p>关于本书</p> <p>本书是我学习和使用 Node.js 的总结。在学习和使用 Node.js 的过程中，我写了不少文章，并对一些文章进行了加工和完善，发表在<a href="https://cnodejs.org/">cnode</a>论坛和Node全栈公众号(nodeonly)上。在2015年初，我在天津创业，位置在空港附近，为了招人不得不做一些科普、布道的工作。当时是被忽悠的，创始人都不拿工资(蠢，被坑死后才知道)，结婚后媳妇在银川，我手上没钱，又不好意思找媳妇要，所以和 StuQ 做了一点课程，效果还不错，后来就和 StuQ 结缘，做知乎 Live 等，霍老板钦定 StuQ 明星讲师。随着 Node.js 科普、布道的增加，我就萌生了写一本书的想法，希望能比较系统地总结相关知识，巩固自己的知识体系，而不是停留在『零散』的状态中。正好被博文视点的大编辑张春雨发现，于是就有了这本书。</p> <p>首先，我参考一些相关的书籍，作了一个基础的思维导图。接下来，就要开始写作了，这也是最艰难的一关。</p> <p>我没有按照从头到尾的顺序写，而是已有相对比较完善的知识点入手，比如Koa框架、异步流程控制等等。就这样，一点一点地写，实在不想写了，就先搁置一下，过两天继续写。整个过程持续了2年，和编辑开玩笑说：“开始写的时候是Node 4.0，交稿的时候Node已经8.0了”。</p> <p>我在写作的过程中，给自己提了一个要求：<strong>尽量深入浅出，条理清晰</strong>。至于是否达到了，希望读者们多多批评指正，并给我提意见和建议。</p> <p>目录</p> <ul> <li><a href>01 Node.js初识</a></li> <li><a href>02 安装与入门</a></li> <li><a href>03 更了不起的Node.js</a></li> <li><a href>04 更好的Node.js</a></li> <li><a href>05 Node.js是如何执行的</a></li> <li><a href>06 模块与核心</a></li> <li><a href>07 异步写法与流程控制</a></li> <li><a href>08 下一代Web框架Koa入门</a></li> <li><a href>09 Koa的核心扩展机制：中间件</a></li> <li><a href>10 HTTP协议必知必会</a></li> <li><a href>11 Koa练习</a></li> <li><a href>12 数据库入门</a></li> <li><a href>13 数据库进阶</a></li> <li><a href>14 视图模板</a></li> <li><a href>15 Koa项目实战</a></li> <li><a href>16 自己动手写NPM模块</a></li> <li><a href>17 Node.js企业级Web开发</a></li> <li><a href>18 构建具有Node.js特色的微服务</a></li> <li><a href>19 让Node.js跑的更稳</a></li> <li><a href>20 让Node.js跑的更快</a></li> </ul> <p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后，20章，800页+，定价预计在130+。</p> <h2>主题演讲</h2> <ul> <li>2018年1月6日 敏捷之旅2017天津站 <a href="http://www.hdb.com/party/r9n52.html">http://www.hdb.com/party/r9n52.html</a></li> <li>2018年1月5日 AI时代的移动技术革新 <a href="https://www.bagevent.com/event/1004907?bag_track=vcr">https://www.bagevent.com/event/1004907?bag_track=vcr</a></li> <li>2017年11月23日 GITC 2017全球互联网技术大会 北京站 <a href="https://www.huodongjia.com/event-1745105617.html">https://www.huodongjia.com/event-1745105617.html</a></li> <li>2017年11月18 天津GDG DevFest 2017 <a href="https://www.meetup.com/GDG-Tianjin/events/244891749/">https://www.meetup.com/GDG-Tianjin/events/244891749/</a></li> <li>imweb腾讯深圳，9月份 <a href="http://imweb.io/topic/5975bf1152e1c21811630619">http://imweb.io/topic/5975bf1152e1c21811630619</a></li> <li>iweb峰会，北京国家会议中心 <a href="http://www.huodongxing.com/event/5393043891500">http://www.huodongxing.com/event/5393043891500</a></li> <li>Oracle Code北京7 月 14 日 <a href="https://developer.oracle.com/code/beijing">https://developer.oracle.com/code/beijing</a></li> <li>2017年06月24日 HTML5梦工场 & 微软开发者沙龙第10期——北京——前端那些事儿 <a href="http://www.html5dw.com/event/4477">http://www.html5dw.com/event/4477</a></li> <li>2017年05月20日 全球首届 Vue.js 开发者大会 <a href="https://segmentfault.com/e/1160000009118583">https://segmentfault.com/e/1160000009118583</a></li> </ul> <h2>精华文章</h2> <p>年度文章《2017，我们来聊聊 Node.js》 <a href="https://cnodejs.org/topic/58eee565a92d341e48cfe7fc%EF%BC%8C%E6%AD%A4%E6%96%87%E6%88%AA%E6%AD%A2%E5%8F%91%E7%A8%BF%E5%B7%B2%E7%BB%8F%E5%8D%95%E7%AF%87%E8%B6%85%E8%BF%87">https://cnodejs.org/topic/58eee565a92d341e48cfe7fc，此文截止发稿已经单篇超过</a> <strong>9万</strong> 阅读量。在qcon大会，被徐川主编选为推荐文章，答疑解惑，大局观还是相当不错的。另外《Node.js 2016 回顾以及2017展望》h ttps://cnodejs.org/topic/588a959b1dc8ff8739cbc66d 也是类似的精华文章。</p> <p>网友yanlele评价</p> <p>毕业开始就开始撸JS，因为以前java出身，始终放不下java，最近两个月才开始真正接触node，一直在想node真的有前景嘛？一直很困扰在下，在下所在的城市，几乎没有用node真正意义上做开发的公司。这篇文章我也是前几天才看到，反反复复看了很多遍，真的写的很好。希望node在未来的18年会越来越好。</p> <p>狼叔回复的《Node相比传统服务端技术栈好在哪里？》<a href="https://cnodejs.org/topic/5a328967d92f2f5b185ace96%EF%BC%8C%E5%9B%9E%E5%A4%8D%E4%B9%8B%E5%90%8E%E6%9F%90%E4%B8%AA%E5%96%B7%E5%AD%90%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E6%8D%AE%E8%AF%B4%E8%B4%BA%E8%80%81hax%E5%9C%A8%E9%98%85%E8%AF%BB%E6%AD%A4%E6%96%87%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%AA%E6%8A%95%E5%85%A5%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%9D%90%E8%BF%87%E7%AB%99%E4%BA%86%E3%80%82">https://cnodejs.org/topic/5a328967d92f2f5b185ace96，回复之后某个喷子的文章，据说贺老hax在阅读此文，因为太投入，导致坐过站了。</a></p> <p>狼叔说：本来不想回复的，匿名的那哥们写的挺好的，虽然不懂他为什么要匿名。但看到某些回复，不得不说几句。乱解读，误人子弟的事，还是有必要澄清的，以免Node有无端被黑，相信这也是所有布道者都应该承担这种除魔卫道的责任。</p> <p>《请别拿“死”人做文章》<a href="https://cnodejs.org/topic/59daf46f2543cb3368b1627e%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%A0%E4%B8%BANode.js%E4%B9%8B%E7%88%B6Ryan">https://cnodejs.org/topic/59daf46f2543cb3368b1627e，主要是因为Node.js之父Ryan</a> Dahl在google使用go，导致某些人过度解读。故而回复，以正视听</p> <p>狼叔说：Node.js之父Ryan Dahl在2012年就离开社区的，我们必须要承认他作为创始人的伟大创举，但不能标签化，ryan不代表node，从他离开社区后，对于社区而言，他就“死”在曾经的丰功伟绩上，未来与他无关！</p> <p>《迷茫时学习Node.js最好的方法》<a href="https://cnodejs.org/topic/59c75a3dd7cbefc511964688%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%8D%E5%93%8D%E8%BF%98%E4%B8%8D%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E9%83%A8%E5%88%86%E4%BA%BA%E7%9A%84%E8%BF%B7%E8%8C%AB%E3%80%82">https://cnodejs.org/topic/59c75a3dd7cbefc511964688，这篇文章反响还不错，解决了部分人的迷茫。</a></p> <p>狼叔说：这是真事儿，在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p> <p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p> <p>《请叫我Node.js 8》兼发布说明，<a href="https://cnodejs.org/topic/592e377e855efbac2cf7a4dd%EF%BC%8CNode.js">https://cnodejs.org/topic/592e377e855efbac2cf7a4dd，Node.js</a> 8的发布是里程碑事件，随后就发布了Koa 2.x正式版。</p> <pre class="prettyprint"><code>为了避免和V8引擎的名字冲突，请叫我Node.js 8 </code></pre><p>核心内容</p> <ul> <li>是下一个长期支持版本</li> <li>更新 V8 到 5.8版本: 核心变更TurboFan & Ingnition（加了jit即时编译）</li> <li>更新 npm 到 5.0.0：宇宙最快+自带lock文件</li> <li>引入新的 c/c++ 扩展方式：N-API，解决addon的编译问题</li> <li>Async函数性能提升</li> <li>Async Hooks API支持</li> </ul> <p>《如果你来设计一个基于Webpack的前端开发工具》<a href="https://cnodejs.org/topic/591919d4ba8670562a40f106%EF%BC%8C%E5%AF%B9%E4%BA%8Ewebpack%E5%92%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%BC%94%E8%AE%B2%EF%BC%8C%E8%87%AA%E4%BB%A5%E4%B8%BA%E6%98%AF%E5%BE%97%E6%84%8F%E4%B9%8B%E4%BD%9C%E3%80%82%E8%83%BD%E5%A4%9F%E7%9C%9F%E6%AD%A3%E4%BB%8E%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%EF%BC%8C%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E6%9D%A5%E5%88%86%E6%9E%90%E7%9A%84%EF%BC%8C%E7%9B%AE%E5%89%8D%E7%9C%8B%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%80%E4%B8%AA%E4%BA%BA%E3%80%82%E5%B8%AE%E7%8E%89%E6%B5%A9review%E4%BA%86%E3%80%8AWebpack">https://cnodejs.org/topic/591919d4ba8670562a40f106，对于webpack和前端工程化演讲，自以为是得意之作。能够真正从如何打包，到浏览器解包过程来分析的，目前看只有我一个人。帮玉浩review了《Webpack</a> 前端工程化入门》<a href="http://gitbook.cn/gitchat/column/59e065f64f7fbe555e479204%E3%80%82%E8%BF%99%E7%AF%87%E5%85%A5%E9%97%A8%E4%B9%9F%E8%BF%98%E6%98%AF%E7%9B%B8%E5%BD%93%E4%B8%8D%E9%94%99%E7%9A%84%E3%80%82">http://gitbook.cn/gitchat/column/59e065f64f7fbe555e479204。这篇入门也还是相当不错的。</a></p> <p>虐狗文《从你的全世界悔过》<a href="https://cnodejs.org/topic/59a4102d9e95202d08c91d45%EF%BC%8C%E6%AD%A4%E6%96%87%E6%98%AF%E4%B8%83%E5%A4%95%E6%97%B6%E7%BB%99%E5%AA%B3%E5%A6%87%E5%86%99%E7%9A%84%E8%AF%97%E6%AD%8C%E4%B8%B2%E8%B5%B7%E6%9D%A5%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E8%AF%B4%E8%AF%BB%E4%BA%86%E8%BF%98%E6%8C%BA%E6%84%9F%E5%8A%A8%EF%BC%8C%E7%9F%A5%E4%B9%8E%E4%B8%8A%E4%B9%9F%E6%94%B6%E8%8E%B7%E4%B8%8D%E5%B0%91%E8%B5%9E%E3%80%82%E8%AF%97%E6%AD%8C%E5%B0%B1%E4%B8%8D%E5%B8%96%E4%BA%86%EF%BC%8C%E6%9D%A5%E4%B8%80%E5%B0%8F%E6%AE%B5%E8%8A%82%E9%80%89%E3%80%82">https://cnodejs.org/topic/59a4102d9e95202d08c91d45，此文是七夕时给媳妇写的诗歌串起来的一篇文章，很多人说读了还挺感动，知乎上也收获不少赞。诗歌就不帖了，来一小段节选。</a></p> <p>“喜欢一个人就是喜欢，不需要什么理由，你看到她第一眼的时候，就知道这个女人会注定陪我一生。我们也没什么物质追求，只是简简单单的，在一起，很开心，想结婚，想和她过一辈子。</p> <p>很多人都知道我的网名是i5ting，这里的ting就是她，张婷的婷！我在很多公众场合都是这样自我介绍的：“大家好，我是i5ting，婷是我媳妇的名字”，然后大家就笑了。”</p> <h2>组织的活动</h2> <ul> <li>2017年7月29日 北京Node Party活动 <a href="https://cnodejs.org/topic/597edd7f8f0313ff0d08d97a">https://cnodejs.org/topic/597edd7f8f0313ff0d08d97a</a></li> <li>2017年3月30日 饿了么前端团队来访去哪儿网 <a href="http://www.sohu.com/a/130839117_505779">http://www.sohu.com/a/130839117_505779</a></li> </ul> <p>北京Node Party活动本想在年再举办一次，奈何太忙，放到2018吧。</p> <h2>付费学习</h2> <ul> <li>狼叔：如何正确学习 Node.js？<a href="https://www.zhihu.com/lives/928687583372926976">https://www.zhihu.com/lives/928687583372926976</a></li> <li>StuQ组织的Live：大前端和 Node.js 那些事 <a href="https://www.zhihu.com/lives/802472054787043328">https://www.zhihu.com/lives/802472054787043328</a></li> <li>Node.js异步流程控制概览与最新的async/await <a href="https://segmentfault.com/l/1500000008716683?_ea=3127449">https://segmentfault.com/l/1500000008716683?_ea=3127449</a></li> <li>白干一年半的被坑的CTO <a href="https://segmentfault.com/l/1500000008716621">https://segmentfault.com/l/1500000008716621</a></li> <li>深入浅出浏览器渲染原理 <a href="http://gitbook.cn/gitchat/activity/59014652fe6a6f3bdac9c49b">http://gitbook.cn/gitchat/activity/59014652fe6a6f3bdac9c49b</a></li> <li>聊聊 Node.js 的历史http://gitbook.cn/gitchat/activity/58d6887577508ce666dbdf35</li> <li>发一个小密圈《狼叔爱Node》，有兴趣的一起来玩 <a href="https://cnodejs.org/topic/58afb00f7872ea0864fee070%EF%BC%8C%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%85%B3%E6%B3%A8nodeonly%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E8%8F%9C%E5%8D%95%E9%87%8C%E5%8D%B3%E5%8F%AF%E5%8A%A0%E5%85%A5%EF%BC%8C%E5%89%8D100%E5%90%8D99%E5%85%83/%E5%B9%B4%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%81%A2%E5%A4%8D%E6%AD%A3%E5%B8%B8%E4%BB%B7%E6%A0%BC199%E5%85%83/%E5%B9%B4">https://cnodejs.org/topic/58afb00f7872ea0864fee070，另外一种办法，关注nodeonly公众号，菜单里即可加入，前100名99元/年，之后恢复正常价格199元/年</a></li> </ul> <h2>诗歌</h2> <p>个人诗集《春天的恐惧症》已付梓，由上海文艺出版社出版，168页，由著名诗人破破作序《物质时代的草甸之子》，在知乎上回复了《程序员可以培养的第二技能有哪些？》<a href="https://www.zhihu.com/question/264575890/answer/291053439">https://www.zhihu.com/question/264575890/answer/291053439</a></p> <pre class="prettyprint"><code> 【很多人说写作，我想说你们那是码字。能高雅点么？】 </code></pre><p>今年诗歌写的少，只有20多首。</p> <ul> <li>我的2017年总结</li> <li>在22楼</li> <li>儿子</li> <li>星空漫想</li> <li>好先生第三十五集观后感</li> <li>《补身份证记》</li> <li>我来的时候风景正好</li> <li>谁说相见不如倾慕</li> <li>节日</li> <li>行走在阳光下</li> <li>书签</li> <li>相聚与相遇</li> <li>媳妇发来宝宝的视频</li> <li>从你的全世界悔过</li> <li>春天的中午</li> <li>大米</li> <li>静静地看着他</li> <li>梦魇</li> <li>无题</li> <li>烟囱与婴儿</li> <li>初冬，一个干活的人</li> </ul> <p>《补身份证记》的后2章节可为很精彩，很多人都非常喜欢。我是很不满的情绪，大概可见一斑。</p> <pre class="prettyprint"><code>这事儿也是有好处的 今天去厕所，无纸 一摸兜，一打还没来得及扔的临时证明 不就是一打纸吗? 虽然有点硬 虽然只有巴掌大小 我把大头照片一一取下 向辉煌抹去 那一刹那 我竟还忍不住感动 临时身份证上，姓名和身份证号码 深深地印在屁股上 </code></pre><p>其实，我个人最喜欢的诗歌是《星空漫想》。缺少的在补，想要的在继续。不知道能有多少人能够理解30岁之后的感谢。其实有很多人跟我一样。</p> <pre class="prettyprint"><code>《星空漫想》 像量天尺一样，鼓起勇气 向夜晚迈出大大的一步 我知道，离星空还远 我只是想给未来一个大大的拥抱 像烟花一样，一飞冲天 燃烧，绚烂，哪怕变成一缕青烟 我知道，生命和星星一样，可望而不可及 只能努力的，不错过每一颗 不知道自己拥有什么 也不知道自己想要什么 仿佛一切，只是向死而生 我们站在星空下，无限渺小 其实你还是你，夜还是夜，星空还是星空 缺少的在补，想要的在继续 在无限的找寻中，一直都是自己与快乐斗争 散落星空的战友，像极了无数个自己 </code></pre><h2>总结</h2> <p>最后用《我的2017年总结》来结尾吧，元旦当晚，我和妻儿一起看电视，吃橘子，感慨一年过往。诗歌写的像故事一样，对比情景，还是比较温暖的。</p> <pre class="prettyprint"><code>这一年特别快 孩子已经快一岁了 我也出去了一年 许多心酸许多感谢 她觉得慢 她只做了一件事儿 照顾孩子，辛苦更多 感恩更多 媳妇给孩儿扒橘子 将橘子皮扒开 将橘子肉分几次 送到孩子嘴里 我给媳妇扒橘子 直接送她嘴里 宝宝拍拍我的肩 一定是嫌我送的快了 </code></pre><h2>预告</h2> <h3>极客时间App上，即将发表《Node.js全栈2018前瞻》专题</h3> <p>写这篇文章的原因是在2017年，我写了一篇<a href="https://cnodejs.org/topic/58eee565a92d341e48cfe7fc">《2017，我们来聊聊 Node.js》</a>，单篇阅读量将近9万，效果还是相当不错的。但很多科普工作做的还不够好，比如在2017年底，被某些喷子在知乎上黑Node.js，当时我虽然回了一篇<a href="https://cnodejs.org/topic/5a328967d92f2f5b185ace96">狼叔回复的《Node相比传统服务端技术栈好在哪里？》</a>，但还是深感焦虑，很多人对Node.js理解的是不太正确的。</p> <p>比如常见问题</p> <ul> <li>Node.js是js语法，能不能像java一样大规模开发？</li> <li>Node.js适不适合写后端？</li> <li>Node.js异步写法太麻烦，回调太恶心。。。</li> <li>Node.js性能到底和go相比如何，我要不要转go？</li> <li>前端技术发展那么快，我该怎么应变？</li> </ul> <p>故而，我打算在本篇文章里把2018年以Node.js为中心的主流趋势科普一下。希望为Node.js正名尽微薄之力。</p> <p>大纲</p> <ol> <li>Node.js2017回顾和2018概览</li> <li>不要异步，我们要同步流程控制：Async函数和更好的ES6模块模块</li> <li>类型系统和面向对象的完美es6超集：TypeScript && flow && coffee</li> <li>大前端、工程化与AI时代应变：Webpack && Weex & Electron</li> <li>日渐成熟的Node.js企业级Web开发框架：Strongloop、Eggjs、Thinkjs</li> <li>Node.js生态、架构演进和商业案例再思考</li> </ol> <h3>【知乎Live】狼叔：如何正确的学习Node.js</h3> <p>Live 简介 你好，我是 i5ting ，江湖人称「狼叔」，目前是阿里巴巴技术专家，斯达克学院（ StuQ ）明星讲师， Node.js 技术布道者。曾就职于去哪儿、新浪、网秦，做过前端、后端、数据分析，是一名全栈技术的实践者。</p> <p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p> <p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p> <p>本次 Live 主要包括以下内容</p> <ol> <li>前言：学习 Node.js 的三个境界</li> <li>准备： <ul> <li>Node 用途那么多，我该从哪里学起？</li> <li>Node Web 框架那么多，我该怎么选？</li> <li>关于 Node 的书几乎都过时了，我该买哪本？</li> </ul> </li> <li>延伸：大前端变化那么快，如何才能做到每日精进？</li> <li>实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</li> <li>答疑：回答大家的问题</li> </ol> <p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，参加地址</p> <p><a href="https://www.zhihu.com/lives/928687583372926976">https://www.zhihu.com/lives/928687583372926976</a></p> <p>时间是明天晚上哦</p> </div>",
title: "我的2017年总结",
last_reply_at: "2018-01-22T07:15:03.159Z",
good: true,
top: false,
reply_count: 7,
visit_count: 715,
create_at: "2018-01-19T12:34:32.687Z",
author: - {
loginname: "i5ting",
avatar_url: "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    },
- {
id: "5a604732afa0a121784a8d28",
author_id: "5a5d5e809288dc8153287e4f",
tab: "share",
content: "<div class="markdown-text"><p><img src=" //dn-cnode.qbox.me/FpISR8xl9cWaE5VFdT0AhJw8lZtc" alt="TIM截图20180118150428.png"></p> <p><a href="https://stackoverflow.com/questions/30452263/is-there-a-mechanism-to-loop-x-times-in-es6-ecmascript-6-without-mutable-varia">来自这里</a></p> <p><strong>看到这个直接懵了，这是啥。。。。。</strong></p> <p><strong>用babel处理了下才算能明白</strong> <img src="//dn-cnode.qbox.me/FrWu3a9E5GETjkSqbTpe_EwjrvvV" alt="TIM图片20180118143855.png"></p> </div>",
title: "哎呀妈呀，这ES6语法，害我想了大半个钟头！",
last_reply_at: "2018-01-22T07:13:22.424Z",
good: false,
top: false,
reply_count: 15,
visit_count: 1062,
create_at: "2018-01-18T07:05:22.291Z",
author: - {
loginname: "baofengyv",
avatar_url: "https://avatars3.githubusercontent.com/u/5669938?v=4&s=120"
        }
    },
- {
id: "58ac640e7872ea0864fedf90",
author_id: "56c336a38442f7e03c7316ae",
tab: "share",
content: "<div class="markdown-text"><h1>《koa2进阶学习笔记》附教程demo</h1> <blockquote> <p>第一次写书，如有错误，欢迎指正！O(∩_∩)O~。 持续更新笔记，后续会根据koa2 正式发布后添加koa2周边生态使用笔记</p> </blockquote> <h2>GitHub地址</h2> <p><a href="https: //github.com/ChenShenhai/koa2-note/">https://github.com/ChenShenhai/koa2-note/</a></p> <h2>GitBook地址</h2> <p><a href="https://chenshenhai.github.io/koa2-note/">https://chenshenhai.github.io/koa2-note/</a></p> <h2>目录</h2> <ul> <li><a href>1. koa2开始</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/start/quick.md">1.1 快速开始</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/start/async.md">1.2 async/await使用</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/start/info.md">1.3 koa2简析结构</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/start/middleware.md">1.4 koa中间件开发与使用</a></li> </ul> </li> <li><a href>2. 路由</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/route/simple.md">2.1 原生koa2实现路由</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/route/koa-router.md">2.2 koa-router中间件</a></li> </ul> </li> <li><a href>3. 请求数据获取</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/request/get.md">3.1 GET请求数据获取</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/request/post.md">3.2 POST请求数据获取</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/request/post-use-middleware.md">3.3 koa-bodyparser中间件</a></li> </ul> </li> <li><a href>4. 静态资源加载</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/static/server.md">4.1 原生koa2实现静态资源服务器</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/static/middleware.md">4.2 koa-static中间件</a></li> </ul> </li> <li><a href>5. cookie/session</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/cookie/info.md">5.1 koa2使用cookie</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/session/info.md">5.2 koa2实现session</a></li> </ul> </li> <li><a href>6. 模板引擎</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/template/add.md">6.1 koa2加载模板引擎</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/template/ejs.md">6.2 ejs模板引擎</a></li> </ul> </li> <li><a href>7. 文件上传</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/busboy.md">7.1 busboy模块</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/simple.md">7.2 上传文件简单实现</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/pic-async.md">7.3 异步上传图片实现</a></li> </ul> </li> <li><a href>8. 数据库mysql</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/info.md">8.1 mysql模块</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/async.md">8.2 async/await封装使用mysql</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/init.md">8.3 项目建表初始化</a></li> </ul> </li> <li><a href>9. JSONP实现</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/jsonp/info.md">9.1 原生koa2实现JSONP</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/jsonp/koa-jsonp.md">9.2 koa-jsonp中间件</a></li> </ul> </li> <li><a href>10. 测试</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/test/unit.md">10.1 单元测试</a></li> </ul> </li> <li><a href>11. debug</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/debug/info.md">11.1 开发debug</a></li> </ul> </li> <li><a href>12. 项目框架搭建</a> <ul> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/start.md">12.1 快速启动</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/framework.md">12.2 框架设计</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/layer.md">12.3 分层操作</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/sql.md">12.4 数据库设计</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/route.md">12.5 路由设计</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/webpack2.md">12.6 webpack2环境搭建</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/react.md">12.7 使用react.js</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/sign.md">12.8 登录注册功能实现</a></li> <li><a href="https://github.com/ChenShenhai/koa2-note/blob/master/note/project/session.md">12.9 session登录态判断处理</a></li> </ul> </li> </ul> <h2>前言</h2> <ul> <li>ES6/7 带来的变革</li> </ul> <p>自ES6确定和ES7的async/await开始普及，node.js的发展变得更加迅速，可以预见到JavaScript中令人“头疼”的多层嵌套回调（注意是”多层嵌套回调“）将会使用Promise + async/await的方式逐渐替代（不是完全替代，多层嵌套回调也有其特殊的应用场景）。</p> <ul> <li>koa2 大势所趋的前景</li> </ul> <p>基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。</p> <h2>初衷</h2> <ul> <li>写笔记目的</li> </ul> <p>从学生到工作写了几年的代码，觉得虽然学习新语言，新框架的主要目的是为了解决实际问题，其中更重要的是要每次入门了一门新技术后要及时留下点学习的痕迹，方便以后忘记可以从学习轨迹中迅速上手。</p> </div>",
title: "《koa2进阶学习笔记》写了关于koa2入门教程的书【持续更新...】",
last_reply_at: "2018-01-22T07:08:08.488Z",
good: false,
top: false,
reply_count: 37,
visit_count: 29035,
create_at: "2017-02-21T16:00:14.030Z",
author: - {
loginname: "ChenShenhai",
avatar_url: "https://avatars3.githubusercontent.com/u/8216630?v=4&s=120"
        }
    },
- {
id: "5a630ae4afa0a121784a8df2",
author_id: "5a5ec12a9288dc8153287eb9",
tab: "ask",
content: "<div class="markdown-text"><p>举例： 前提：系统有三方 1. 运营方、2. 店铺（B端用户）3. 用户（C端用户） 用户进行下单操作 接口定义： 查询订单详情接口： To B: /sellers/:sellerId/orders/:orderId To C: /buyers/:buyerId/orders/:orderId 问题： 对于订单的这样的实体好解释，订单可以是用户的也可以是属于店铺的。如果只有运营平台和买方，运营平台查询一个商品信息可以是/items/:itemId，用户查看也是/items/:itemId。查询出来的信息，应该是运营平台要多一些，类似商品的销售提成这样的信息。如何定义RESTful路由？</p> </div>",
title: "RESTful接口定义 对于相同实体的查询接口 后台管理员和用户的接口分别如何定义？",
last_reply_at: "2018-01-22T06:53:51.018Z",
good: false,
top: false,
reply_count: 5,
visit_count: 242,
create_at: "2018-01-20T09:24:52.033Z",
author: - {
loginname: "guo-q",
avatar_url: "https://avatars1.githubusercontent.com/u/31874238?v=4&s=120"
        }
    },
- {
id: "5a5c0408a3692d014f4f1473",
author_id: "5a5c03aca3692d014f4f1472",
tab: "share",
content: "<div class="markdown-text"><p>学习Node 第一天,希望能够找个好工作, 坐标郑州</p> </div>",
title: "学习Node 第一天,希望能够找个好工作, 坐标郑州",
last_reply_at: "2018-01-22T06:07:38.356Z",
good: false,
top: false,
reply_count: 24,
visit_count: 956,
create_at: "2018-01-15T01:29:44.861Z",
author: - {
loginname: "AmandaYi",
avatar_url: "https://avatars1.githubusercontent.com/u/23202919?v=4&s=120"
        }
    },
- {
id: "5a653e5aafa0a121784a8e2e",
author_id: "5a3075929807389a1809f330",
tab: "ask",
content: "<div class="markdown-text"><p>如题</p> </div>",
title: "cnode搜索是google的站内搜索么？没翻墙。怎么搜索问题？",
last_reply_at: "2018-01-22T05:09:10.069Z",
good: false,
top: false,
reply_count: 4,
visit_count: 154,
create_at: "2018-01-22T01:28:58.735Z",
author: - {
loginname: "varwx",
avatar_url: "https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"
        }
    },
- {
id: "595d9ad5a4de5625080fe118",
author_id: "595d976b10d696af07768a24",
tab: "share",
content: "<div class="markdown-text"><h1>Mongoose快速入门</h1> <h1>1.基础介绍</h1> <h2>1.1安装 引用</h2> <p>启动数据库命令</p> <pre class="prettyprint"><code>	mongod --dbpath=D:\Data\mongodb\_data </code></pre><p>–dbpath：指定数据存储位置</p> <p>连接本地的test数据库</p> <pre class="prettyprint"><code>	var mongoose = require('mongoose'); var db = mongoose.connect("mongodb: //127.0.0.1:27017/test"); db.connection.on("error", function (error) { console.log("数据库连接失败：" + error); }); db.connection.on("open", function () { console.log("------数据库连接成功！------"); }); </code></pre><h2>1.2 Schema简介</h2> <p>Schema：一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是"集合"的模型骨架。</p> <p>那如何去定义一个Schema呢，请看示例：</p> <pre class="prettyprint"><code>	var mongoose = require("mongoose"); var TestSchema = new mongoose.Schema({ name : { type:String },//属性name,类型为String age : { type:Number, default:0 },//属性age,类型为Number,默认为0 time : { type:Date, default:Date.now }, email: { type:String,default:''} }); </code></pre><blockquote> <p>注：Schema定义集合结构（定义表的列）</p> </blockquote> <h2>1.3 Model–操作数据库</h2> <pre class="prettyprint"><code> var db = mongoose.connect("mongodb://127.0.0.1:27017/test"); // 创建Model var TestModel = db.model("test1", TestSchema); ## 1.4 Entity--给集合赋值 var TestEntity = new TestModel({ name : "Lenka", age : 36, email: "lenka@qq.com" }); console.log(TestEntity.name); // Lenka console.log(TestEntity.age); // 36 </code></pre><h2>1.5 创建集合</h2> <pre class="prettyprint"><code>	//引入数据库模块 var mongoose = require("mongoose"); //连接本地名为test的数据库，格式 //var db = mongoose.connect("mongodb://user:pass@localhost:port/database"); var db = mongoose.connect("mongodb://127.0.0.1:27017/test"); //用Schema定义集合结构 var TestSchema = new mongoose.Schema({ name : { type:String }, age : { type:Number, default:0 }, email: { type:String }, time : { type:Date, default:Date.now } }); //创建model,在内存中创建结构为TestSchema名为test1的集合 var TestModel = db.model("test1", TestSchema ); //插入数据到内存中的test1集合 var TestEntity = new TestModel({ name : "helloworld", age : 28, email: "helloworld@qq.com"	}); //将test1写入到数据库中 TestEntity.save(function(error,doc){ if(error){ console.log("error :" + error); }else{ console.log(doc); } }); </code></pre><h2>1.6 小结</h2> <p>本章节学习了如何通过Mongoose去创建一个数据库"集合"，还有定义"集合"的基本组成结构并使其具有相应的操作数据库能力。</p> <p>简单回顾：</p> <ol> <li> <p>Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。</p> </li> <li> <p>Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。</p> </li> <li> <p>Entity：通过Model创建的实体，它也可以操作数据库。</p> </li> </ol> <h1>2 增删改查</h1> <h2>2.1查询</h2> <pre class="prettyprint"><code>find查询： obj.find(查询条件,callback); Model.find({},function(error,docs){ //若没有向find传递参数，默认的是显示所有文档 }); Model.find({ "age": 28 }, function (error, docs) { if(error){ console.log("error :" + error); }else{ console.log(docs); //docs: age为28的所有文档 } }); </code></pre><h2>2.2model保存方法</h2> <pre class="prettyprint"><code>Model.create(文档数据, callback)) Model.create({ name:"model\_create", age:26}, function(error,doc){ if(error) { console.log(error); } else { console.log(doc); } }); </code></pre><h2>2.3 entity保存方法</h2> <pre class="prettyprint"><code>Entity.save(文档数据, callback)) var Entity = new Model({name:"entity\_save",age: 27}); Entity.save(function(error,doc) { if(error) { console.log(error); } else { console.log(doc); } }); model调用的是create方法，entity调用的是save方法 </code></pre><h2>2.4 数据更新</h2> <pre class="prettyprint"><code>obj.update(查询条件,更新对象,callback); var conditions = {name : 'test\_update'}; var update = {$set : { age : 16 }}; TestModel.update(conditions, update, function(error){ if(error) { console.log(error); } else { console.log('Update success!'); } }); </code></pre><h2>2.5 删除数据</h2> <pre class="prettyprint"><code>obj.remove(查询条件,callback); var conditions = { name: 'tom' }; TestModel.remove(conditions, function(error){ if(error) { console.log(error); } else { console.log('Delete success!'); } }); </code></pre><h2>2.6 小结</h2> <ol> <li> <p>查询：find查询返回符合条件一个、多个或者空数组文档结果。</p> </li> <li> <p>保存：model调用create方法，entity调用的save方法。</p> </li> <li> <p>更新：obj.update(查询条件,更新对象,callback)，根据条件更新相关数据。</p> </li> <li> <p>删除：obj.remove(查询条件,callback)，根据条件删除相关数据。</p> </li> </ol> <h1>3 简单查询</h1> <h2>3.1 find过滤查询</h2> <p>属性过滤 find(Conditions,field,callback);</p> <p>field省略或为Null，则返回所有属性。</p> <pre class="prettyprint"><code>	//返回只包含一个键值name、age的所有记录 Model.find({},{name:1, age:1, \_id:0}，function(err,docs){ //docs 查询结果集 }) </code></pre><blockquote> <p>说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的，_id是默认返回，如果不要显示加上("_id":0)，但是，对其他不需要显示的属性且不是_id，如果设置为0的话将会抛异常或查询无果</p> </blockquote> <h2>3.2 小结</h2> <ol> <li> <p>find过滤查询 ：find查询时我们可以过滤返回结果所显示的属性个数。</p> </li> <li> <p>findOne查询 ：只返回符合条件的首条文档数据。</p> </li> <li> <p>findById查询：根据文档_id来查询文档。</p> </li> </ol> <h1>4.高级查询</h1> <h2>4.1 大于、小于</h2> <p>$gt(>)、$lt(<)、$lte(<=)、$gte(>=)</p> <p>示例：</p> <pre class="prettyprint"><code> Model.find({"age":{"$gt":18}},function(error,docs){ //查询所有nage大于18的数据 }); </code></pre><h2>4.2不等于</h2> <p>$ne(!=)</p> <p>示例：</p> <pre class="prettyprint"><code> Model.find({ age:{ $ne:24}},function(error,docs){ //查询age不等于24的所有数据 }); </code></pre><p><strong>$ne可以匹配单个值，也可以匹配不同类型的值。</strong></p> <h2>4.3 匹配</h2> <p>$in 包含、等于</p> <p>示例：</p> <pre class="prettyprint"><code> Model.find({ age:{ $in: 20}},function(error,docs){ //查询age等于20的所有数据 }); Model.find({ age:{$in:[20,30]}},function(error,docs){ //可以把多个值组织成一个数组 }); </code></pre><h2>4.4 或者</h2> <p>$or</p> <p>示例：</p> <pre class="prettyprint"><code> Model.find({"$or":[{"name":"yaya"},{"age":28}]},function(error,docs){ //查询name为yaya或age为28的全部文档 }); </code></pre><h2>4.5 存在</h2> <p>$exists</p> <p>示例：</p> <pre class="prettyprint"><code> Model.find({name: {$exists: true}},function(error,docs){ //查询所有存在name属性的文档 }); Model.find({telephone: {$exists: false}},function(error,docs){ //查询所有不存在telephone属性的文档 }); </code></pre><h2>4.6 小结</h2> <ol> <li> <p>$gt(>),$lt(<),$lte(<=),$gte(>=)操作符：针对Number类型的查询具体超强的排除性。</p> </li> <li> <p>$ne(!=)操作符：相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。</p> </li> <li> <p>$in操作符：和$ne操作符用法相同，但意义相反。</p> </li> <li> <p>$or操作符：可查询多个条件，只要满足其中一个就可返回结果值。</p> </li> <li> <p>$exists操作符：主要用于判断某些属性是否存在。</p> </li> </ol> <h1>5.游标</h1> <h2>5.1 简介</h2> <p>数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p> <h2>5.2 limit函数的基本用法</h2> <p>限制数量：find(Conditions,fields,options,callback);</p> <pre class="prettyprint"><code> Model.find({},null,{limit:20},function(err,docs){ console.log(docs); }); </code></pre><h2>5.3 skip函数的基本用法</h2> <p>skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。</p> <p>示例：</p> <p>1.跳过数量：find(Conditions,fields,options,callback);</p> <pre class="prettyprint"><code>Model.find({},null,{skip:4},function(err,docs){ console.log(docs); }); </code></pre><p><strong>如果查询结果数量中少于4个的话，则不会返回任何结果。</strong></p> <h2>5.4 sort函数的基本用法</h2> <p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。</p> <p>1.结果排序：find(Conditions,fields,options,callback);</p> <pre class="prettyprint"><code> Model.find({},null,{sort:{age:-1}},function(err,docs){ //查询所有数据，并按照age降序顺序返回数据docs }); </code></pre><h2>5.6 小结</h2> <ol> <li> <p>limit函数：限制返回结果的数量。</p> </li> <li> <p>skip函数：略过指定的返回结果数量。</p> </li> <li> <p>sort函数：对返回结果进行有效排序。</p> </li> </ol> <h1>6 属性方法</h1> <h2>6.1 实例方法</h2> <p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：</p> <pre class="prettyprint"><code> var mongoose = require('mongoose'); var saySchema = new mongoose.Schema({name : String}); saySchema.method('say', function () { console.log('Trouble Is A Friend'); }) var say = mongoose.model('say', saySchema); var lenka = new say(); lenka.say(); //Trouble Is A Friend </code></pre><h2>6.2 Schema静态方法</h2> <p>示例：</p> <pre class="prettyprint"><code> var mongoose = require("mongoose"); var db = mongoose.connect("mongodb://127.0.0.1:27017/test"); var TestSchema = new mongoose.Schema({ name : { type:String }, age : { type:Number, default:0 }, email: { type:String, default:"" }, time : { type:Date, default:Date.now } }); TestSchema.static('findByName', function (name, callback) { return this.find({ name: name }, callback); }); var TestModel = db.model("test1", TestSchema ); TestModel.findByName('tom', function (err, docs) { //docs所有名字叫tom的文档结果集 }); </code></pre><h2>6.3 Schema追加方法</h2> <p>为Schema模型追加speak方法</p> <p>示例：</p> <pre class="prettyprint"><code> var mongoose = require("mongoose"); var db = mongoose.connect("mongodb://127.0.0.1:27017/test"); var TestSchema = new mongoose.Schema({ name : { type:String }, age : { type:Number, default:0 }, email: { type:String, default:"" }, time : { type:Date, default:Date.now } }); TestSchema.methods.speak = function(){ console.log('我的名字叫'+this.name); } var TestModel = db.model('test1',TestSchema); var TestEntity = new TestModel({name:'Lenka'}); TestEntity.speak();//我的名字叫Lenka </code></pre><blockquote> <p>强力推荐：<a href="http://www.hubwiz.com/">汇智网</a></p> </blockquote> </div>",
title: "Mongoose快速入门",
last_reply_at: "2018-01-22T04:11:15.179Z",
good: false,
top: false,
reply_count: 7,
visit_count: 988,
create_at: "2017-07-06T02:05:09.647Z",
author: - {
loginname: "18820227745",
avatar_url: "https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"
        }
    },
- {
id: "5a6303479288dc8153287fe1",
author_id: "5909444b782dbc4b183ecfe2",
tab: "share",
content: "<div class="markdown-text"><p>最近在研究P2P技术，奈何相关资料不多，自己琢磨了一下，分享一下学习P2P的一些原理, 以及如何打造一个P2P聊天应用。</p> <p>这里指的P2P是指<strong>peer to peer</strong>， 点对点的技术， 每个客户端都是服务端，没有中心服务器，不是websocket针对某个connection推送消息。</p> <h3>技术要点</h3> <ul> <li>udp协议</li> <li>节点之间的建立，连接和广播</li> <li>内网穿透，如何能让两个处在内网的节点，相互发现自己的存在，并且建立通信</li> </ul> <h3>原理</h3> <p>首先解决的是内网穿透的问题，常见的底层协议tcp，udp，他们各自有优缺点，简单说明一下。 tcp：需要处理粘包问题，双工流通道，是可靠的链接。 udp： 每次发送的都是数据包，没有粘包问题，但是连接不可靠，只能传输少量数据</p> <p>更加详细的请Google</p> <p>这里选择udp协议，简单一些。</p> <p>再下来是内网穿透，先说结论： <strong>两个处于不同内部网络的节点，永远无法发现他们之间的相互存在</strong>，你就算是想顺着网线过去打他都不行。</p> <p>所有的内网穿透原理无外乎需要一个有公网ip的中介服务器，包括虚拟货币像比特币之类的，所以首先要有一个<strong>创世节点</strong></p> <p>在NodeJS中，创建udp服务也很简单</p> <pre class="prettyprint language-javascript"><code>const dgram = require("dgram"); const udp = dgram.createSocket("udp4"); udp.bind(1090, callback) </code></pre><p>把服务部署要公网，那么其他所有的节点都能访问，通过中转服务器，能够使得两个节点可以建立连接</p> <p><img src=" //dn-cnode.qbox.me/FsnZMj1j1jTUVChZ3KxqtJtty5mq" alt="节点.png"></p> <p>我们是要建立这样的P2P网络</p> <p><img src="//dn-cnode.qbox.me/FmJ2Ugbj3OOVqzkKeG-qpRJyvGC6" alt="网络.png"></p> <p>假如现在只有3个节点： <strong>创世节点</strong>, <strong>B节点</strong>, <strong>C节点</strong>， 创世节点有公网IP</p> <p>我用对话的形式，阐述他们建立链接的过程:</p> <blockquote> <p>B节点: hey，创世节点，我要加入到P2P网络里面，告诉其他兄弟，我来了 创世节点: 兄弟们，刚刚有个叫做B的节点加入网络了，你们也去告诉其他节点 其他节点: 刚刚收到来自 "创世节点"的通知，有个fresh meet加入网络了，叫做 “B”</p> </blockquote> <p>… 至此，所有人都知道了B节点加入了网络，里面记载着B节点的相关信息，包括IP地址，包括udp端口号</p> <p>此时C节点也要加入网络，并且想要和B节点对话:</p> <blockquote> <p>C节点: hey，创世节点，我要加入到P2P网络里面，并且我要和B对话 创世节点: 兄弟们，刚刚有个叫做B的节点加入网络了，你们也去告诉其他节点，顺便看看有没有B这个节点 其他节点: 刚刚收到来自 "创世节点"的通知，有个fresh meet加入网络了，叫做 “C”，你们也看看有没有B这个节点 其他节点2: 收到通知，听说一个叫做C的节点在找一个B节点，我这里有它的信息，ip是xxxx.xxxx.xxx.xxxx, 端口10086 B节点: 有个C的家伙(ip: xxxx.xxxx.xxxx.xxxx, 端口1000)要找我</p> </blockquote> <p>到这里，B获取到了C的信息，包括IP和端口，C也拿到了B的信息.</p> <p>于是，他们两个就可以建立通信。消息流: B <----> C. 中间不经过任何服务器</p> <p>用一张图来形容:</p> <p><img src="//dn-cnode.qbox.me/FrJP9zk_RzD5PSTIHhDoSQUzZB85" alt="new.png"></p> <h3>总结</h3> <p>在设计中，每个节点的功能都是一样的。如果需要加入到网络中，不一定跟创世节点链接</p> <p>假设已存在的节点: 创世节点，A、B、C节点，此时有个D节点想要加入到网络。</p> <p>那么D节点不一定非得链接到创世节点，可以链接到A、B、C中的任意一个节点，然后该节点再广播给其他节点说"Hey, 有个新人叫做D的加入了网络"。</p> <p>这样所有人都知道，有个叫做D的节点存在，你可以和它通信，同时D节点和会同步已存在的节点。这样D节点也知道了其他节点的存在了。</p> <h3>最后</h3> <p>基于这一原理，可以打造出一个P2P的聊天应用，没有中间商赚差价。</p> <p>这只是一些基本原理，离实际应用还差很多，有很多坑，比如D节点退出网络之后，要广播 “D节点退出网络了，把这个节点注销了吧，这波没他"，还有消息加密，通信的双向验证(A节点想要B节点通信，但是不需要B节点的同意)等等，坑太多，填不完</p> <p>原计划是搭建这么一个网络，然后写个electron的聊天应用，但是精力有限，就这样了。<a href="https://github.com/axetroy/p2p-chat">代码</a>(写的丑，轻拍)</p> <p>文字功底有点差，表述不清楚，见谅，如文中有误，欢迎指正与交流。</p> <p><img src="http://i01.pic.sogou.com/9ffb608227cf81da" alt></p> <p>年后正在找一份NodeJS的工作，坐标深圳，哪里能投递</p> </div>",
title: "搭建P2P网络的原理",
last_reply_at: "2018-01-22T03:40:21.525Z",
good: false,
top: false,
reply_count: 5,
visit_count: 295,
create_at: "2018-01-20T08:52:23.029Z",
author: - {
loginname: "axetroy",
avatar_url: "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
        }
    },
- {
id: "5a655c8cafa0a121784a8e40",
author_id: "5976b9b80c87675e74674819",
tab: "ask",
content: "<div class="markdown-text"><p>各位大牛，新买的阿里云数据盘，想把mysql的数据挂在在数据盘下，操作如下： 在/mnt目录下创建mysql文件夹，命令：mkdir mysql</p> <p>停掉mysql服务：命令：/etc/init.d/mysql stop</p> <p>以新目录为/mnt/mysql/为例，复制原来的数据库到新目录下： 命令：cp -R /var/lib/mysql/* /mnt/mysql/</p> <p>将新目录赋权为mysql组：命令：chown mysql:mysql -R /mnt/mysql/</p> <p>修改配置文件： 首先打开配置文件：vim /etc/mysql/my.cnf</p> <p>将datadir = /var/lib/mysql这一行修改为： datadir = /mnt/mysql</p> <p>启动mysql：命令：/etc/init.d/mysql start</p> <p>挂在后，发现数据存储后，数据盘占用的空间并没有变化，反而系统盘占用的空间变大了，想问是哪里出了问题呢？？？谢谢！！！</p> </div>",
title: "linux系统盘挂在",
last_reply_at: "2018-01-22T03:37:48.679Z",
good: false,
top: false,
reply_count: 0,
visit_count: 70,
create_at: "2018-01-22T03:37:48.679Z",
author: - {
loginname: "quanpf2481",
avatar_url: "https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"
        }
    },
- {
id: "5a65496dafa0a121784a8e34",
author_id: "5a6546a5afa0a121784a8e33",
tab: "ask",
content: "<div class="markdown-text"><p>第一次访问没有问题，第二次访问会卡在执行SQL的地方。<img src=" //dn-cnode.qbox.me/FuUctYod8Y4UeugvgVvFgN0xYiDH" alt="错误2.png"> 代码如下： tedious.js const Connection = require(‘tedious’).Connection;<br> const Request = require(‘tedious’).Request;</p> <p>exports.mssql = function(config){<br> this.connection = new Connection(config);</p> <pre class="prettyprint"><code>this.query = function(str,callback){ //执行查询 var connection = this.connection; var rows={}; connection.on('connect', function(err){ //连接数据库，执行匿名函数 if(err){ callback({'err':err['message']+'请检查账号、密码是否正确,且数据库存在'}); }else{ var request = new Request(str,function(err, rowCount){ if(err)err = {'err':err['message']}; callback(err,rows); // connection.close(); }); var n=0; request.on('row', function(columns) { //查询成功数据返回 rows[n]={}; columns.forEach(function(column) { rows[n][column.metadata.colName] = column.value; //获取数据 }); n++; }); connection.execSql(request); //执行sql语句 } }); } </code></pre><p>}</p> <p>client2.js：</p> <p>const request = require(‘request-json’); var client = request.createClient(‘<a href="http://192.168.1.83:8081/">http://192.168.1.83:8081/</a>’);</p> <p>var mssql = require(’./tedious.js’); var conn = new mssql.mssql({ ‘userName’: ‘sa’, ‘password’: ‘123’, ‘server’: ‘localhost’, ‘options’: { ‘port’: 1433, ‘database’: ‘WEIGHT20’ } });</p> <p>var lastId = 0; var timeBw = 1 * 1000;</p> <p>class postData { _getDate(fc) {</p> <pre class="prettyprint"><code> console.log('取称重数据 ID', lastId); var sql = 'SELECT top 1 * FROM \u79f0\u91cd\u4fe1\u606f where \u5e8f\u53f7>' + lastId + ' order by \u5e8f\u53f7 '; console.log('SQL', sql); conn.query(sql, function (err, data) { if (!err) { //console.log(data) //成功返回数据 fc(data); } else { fc([]); console.log(err) //出错返回 } } ); } _postDate(item, fc) { lastId = item['\u5e8f\u53f7']; var postData = {}; postData['creator_id'] = item['\u5e8f\u53f7']; postData['weight_id'] = 'code002'; postData['weight_code'] = 'code002'; postData['weight_rfid'] = '0'; postData['veh_id'] = item['\u6d41\u6c34\u53f7']; postData['car_no'] = item['\u8f66\u53f7']; postData['weight_gross'] = item['\u6bdb\u91cd']; postData['weight_veh'] = item['\u76ae\u91cd']; postData['weight_net'] = item['\u51c0\u91cd']; postData['garbage_type'] = item['\u8d27\u540d']; postData['weight_date'] = item['\u76ae\u91cd\u65f6\u95f4']; postData['delivery_unit'] = item['\u53d1\u8d27\u5355\u4f4d']; postData['prj_id'] = 2; postData['tcar_company_id'] = 0; postData['creator_id'] = item['\u5e8f\u53f7']; console.log('post data', postData); client.post('/jsonapi/cancu_weight/add.json', postData, function (err, res, body) { if (err) { console.error(err); } else { console.log('post resp', body); fc({ code: 0 }); } }); } _time(fc) { var _self = this; _self._getDate((d) => { if (d.length <= 0) { fc({ code: -1 }); return; } _self._postDate(d[0], fc); }) } run(fc) { var _self = this; _self._time(d => { setTimeout(function () { _self.run(); }, timeBw); }, timeBw) } </code></pre><p>}</p> <p>var t = new postData(); t.run();</p> <p><strong>请各位大佬指点</strong></p> </div>",
title: "求助大佬，使用tedious模块连接SQLserver数据库遇到的问题。",
last_reply_at: "2018-01-22T02:16:13.072Z",
good: false,
top: false,
reply_count: 0,
visit_count: 78,
create_at: "2018-01-22T02:16:13.072Z",
author: - {
loginname: "adduan",
avatar_url: "https://avatars3.githubusercontent.com/u/35551072?v=4&s=120"
        }
    },
- {
id: "5a649ff09d371d4a059eecb4",
author_id: "5a5c0a17a3692d014f4f1477",
tab: "share",
content: "<div class="markdown-text"><p>技术有点吐，大佬要多多指教。</p> <p>用到的技术有 vue全家桶，hadoop</p> <p>还在开发中，后期开源—</p> <p><img src=" //dn-cnode.qbox.me/FqRYcmVVSAYEnoptBmavZGOFrvN2" alt="63$6$ZJ%Y7QY6VMVO6P2AW7.png"></p> <p>hadoop web-restfu-api 操作 配置图 <img src="//dn-cnode.qbox.me/FoFz-8tqgi49utaBGEeYqKQp16d4" alt="hadoop-web-restful-api.png"></p> </div>",
title: "vue-Hadoop 网盘Demo 实战",
last_reply_at: "2018-01-21T14:13:04.408Z",
good: false,
top: false,
reply_count: 0,
visit_count: 180,
create_at: "2018-01-21T14:13:04.408Z",
author: - {
loginname: "1160007652",
avatar_url: "https://avatars3.githubusercontent.com/u/26641790?v=4&s=120"
        }
    },
- {
id: "5a649ed5afa0a121784a8e22",
author_id: "584139e9539c22b15689981c",
tab: "ask",
content: "<div class="markdown-text"><p>我们是做Electron应用的，需要找个在客户端存数据用的库。 主要看中的点是：API简洁易懂，速度够快，每种操作有Callback方法。</p> <p>看了大概四五个库的说明，有levelDb，pouchDB，LokiJS等等，整体感觉nedb不错。 查了半天，看到有人说，整个数据库最大只能达到256M，这个对我们来说还好。</p> <p>请问，这个库还有其他坑需要注意吗？ 多谢各位</p> </div>",
title: "请问各位用过nedb的大神，这个数据库有什么坑吗？",
last_reply_at: "2018-01-21T14:08:21.951Z",
good: false,
top: false,
reply_count: 0,
visit_count: 142,
create_at: "2018-01-21T14:08:21.951Z",
author: - {
loginname: "hz0324",
avatar_url: "https://avatars0.githubusercontent.com/u/5040078?v=4&s=120"
        }
    },
- {
id: "5746cdcf991011691ef17b88",
author_id: "57329f1c2e11c7a80c33f87a",
tab: "share",
content: "<div class="markdown-text"><p>express作为nodejs平台下非常流行的web框架，相信大家都对其已经很熟悉了，对于express的使用这里不再多说，如有需要可以移步到<a href>www.expressjs.com</a>自行查看express的官方文档，今天主要是想说下express的路由机制。</p> <p>最近抽时间看了下express的源码，看完源码体会最深刻的还是express的路由机制，感觉搞懂了express的路由就算是基本搞懂了express，而express的路由机制都是router模块来实现，所以在这里对express的router模块实现进行一下简单的整理，所有理解都来自自己对源码的理解，如有不对的地方，还请各位多多拍砖。</p> <p>好了，废话不多说了，进入正题，首先先了解一下express源码的目录结构，如下图： <img src=" //dn-cnode.qbox.me/FnuptVMv5TZchESOT0JRT0re7KZ0" alt="express.jpg"> application.js为express的主文件，express.js对application.js进行了包装，对外提供各种API，这里我们不多做说明，我们今天要说的就是router目录下的内容，express关于路由的具体实现都是由这个目录完成。我们先看一个简单的express路由的例子：</p> <pre class="prettyprint"><code>var app = express(); app.get('/hello', function(req,res){ res.send('hello everyone!!!'); }); </code></pre><p>上边就是一个最简单的express路由的例子，将path为 ‘/hello’ 的请求路由到当前的处理函数，并返回 ‘hello everyone!!!’ ，那么我们来一起看看，app.get()何实现的，通过查看代码我们发现源码里并没有app.get()的实现，但仔细找找你会在application.js中发现如下的代码：</p> <pre class="prettyprint"><code>methods.forEach(function(method){ app[method] = function(path){ if (method === 'get' && arguments.length === 1) { // app.get(setting) return this.set(path); } this.lazyrouter(); var route = this._router.route(path); route[method].apply(route, slice.call(arguments, 1)); return this; }; }); </code></pre><p>(⊙o⊙)哦，隐藏的好深，原来express对get，post等方法的添加都是动态的，methods来自<a href="https://www.npmjs.com/package/methods">methods</a>这个模块，他提供了和nodejs http.METHODS 相似的东西，返回了http协议的所有method，这样一个循环搞定了所有method函数的定义，赞一个。</p> <p>接下来我们主要分析下函数内部的实现，首先判断如果method等于get，并且参数的长度是1，则直接返回this.set(path)，大家查看express官网的API就可以发现，app.get()函数其实实现了两种功能，如果参数长度是1，则返回app.set()定义的变量，如果参数长度大于1，则进行路由处理。</p> <p>继续往下看，<strong>this.lazyrouter()</strong>，从名字来看，好像是懒加载router，那我们看看源码：</p> <pre class="prettyprint"><code>app.lazyrouter = function lazyrouter() { if (!this._router) { this._router = new Router({ caseSensitive: this.enabled('case sensitive routing'), strict: this.enabled('strict routing') }); this._router.use(query(this.get('query parser fn'))); this._router.use(middleware.init(this)); } }; </code></pre><p>果然是，如果_router不存在，就new一个Router出来，而这个Router就是我们刚才在目录结构中看到的router目录，也就是今天的主角Router模块。继续上边的代码，加载完_router之后，执行了**this._router.route(path)**这样一行代码，那这行代码有做了什么呢，我们再继续往下挖，我们在router目录下的index.js中找到了它的实现：</p> <pre class="prettyprint"><code>proto.route = function route(path) { var route = new Route(path); var layer = new Layer(path, { sensitive: this.caseSensitive, strict: this.strict, end: true }, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route; }; </code></pre><p>我们可以看到，这里new了一个Route对象，并且new了一个Layer对象，然后将Route对象赋值给layer.route，最后将这个Layer添加到stack数组中。在这里我们先不对Layer进行说明，后边会有专门的介绍，我们先来看看Route，那这个Route又是什么呢，它和Router模块有什么关系呢，我来说下我的理解：</p> <blockquote> <p>Route模块对应的是route.js，主要是来处理路由信息的，每条路由都会生成一个Route实例。而Router模块对应的是index.js，Router是一个路由的集合，在Router模块下可以定义多个路由，也就是说，一个Router模块会包含多个Route模块。通过上边的代码我们已经知道，每个express创建的实例都会懒加载一个_router来进行路由处理，这个_router就是一个Router模块。</p> </blockquote> <p>理解了Route和Router的关系，感觉一下子清爽了有木有，O(∩_∩)O哈哈~~~</p> <p>好了，我们接着看代码，拿到route对象之后，通过apply的方式调用了route的对应method函数，假如我们现在使用的是get函数，那现在method就等于get。看到这里大家就会发现，express实例在处理路由的时候，会先创建一个Router对象，然后用Router对象和对应的path来生成一个Route对象，最后由Route对象来处理具体的路由实现。</p> <p>好了，那接下来我们继续深入研究，看看route.method究竟做了什么，我们找到route.js文件，发现如下的代码：</p> <pre class="prettyprint"><code>methods.forEach(function(method){ Route.prototype[method] = function(){ var handles = flatten(slice.call(arguments)); for (var i = 0; i < handles.length; i++) { var handle = handles[i]; if (typeof handle !== 'function') { var type = toString.call(handle); var msg = 'Route.' + method + '() requires callback functions but got a ' + type; throw new Error(msg); } debug('%s %s', method, this.path); var layer = Layer('/', {}, handle); layer.method = method; this.methods[method] = true; this.stack.push(layer); } return this; }; }); </code></pre><p>啊啊啊，原来route和application运用了同样的技巧，通过循环methods来动态添加method函数，我们直接看函数内部实现，首先通过入参获取到handles，这里的handles就是我们定义的路由中间件函数，这里我们可以看到是一个数组，所以我们可以给一个路由添加多个中间件函数。接下来循环handles，在每个循环中利用handle来创建一个Layer对象，然后将Layer对象push到stack中去，这个stack其实是Route内部维护的一个数组，用来存放所有的Layer对象。现在你一定想这道这个Layer到底是什么东西，那我们继续往下看，看看layer.js的源代码：</p> <pre class="prettyprint"><code>function Layer(path, options, fn) { if (!(this instanceof Layer)) { return new Layer(path, options, fn); } debug('new %s', path); var opts = options || {}; this.handle = fn; this.name = fn.name || '<anonymous>'; this.params = undefined; this.path = undefined; this.regexp = pathRegexp(path, this.keys = [], opts); if (path === '/' && opts.end === false) { this.regexp.fast_slash = true; } } </code></pre><p>上边是Layer的构造函数，我们可以看到这里定义handle，params，path和regexp等几个主要的属性：</p> <ol> <li>其中最重要的就是handle，它就是我们刚刚在route中创建Layer对象传入的中间件函数。</li> <li>params其实就是req.params，至于如何实现的我们可以以后再做探讨，今天先不做说明。</li> <li>path就是我们定义路由时传入的path。</li> <li>regexp对于Layer来说是比较重要的一个属性，因为下边进行路由匹配的时候就是靠它来搞定的，而它的值是由pathRegexp得来的，其实这个pathRegexp对应的是一个第三方模块<a href="https://www.npmjs.com/package/path-to-regexp">path-to-regexp</a>，它的功能是将path转换成regexp，具体用法大家可以自行查看。</li> </ol> <p>看完属性，我们再来看看Layer有什么方法：</p> <pre class="prettyprint"><code>Layer.prototype.match = function match(path) { if (path == null) { // no path, nothing matches this.params = undefined; this.path = undefined; return false; } if (this.regexp.fast_slash) { // fast path non-ending match for / (everything matches) this.params = {}; this.path = ''; return true; } var m = this.regexp.exec(path); if (!m) { this.params = undefined; this.path = undefined; return false; } // store values this.params = {}; this.path = m[0]; var keys = this.keys; var params = this.params; for (var i = 1; i < m.length; i++) { var key = keys[i - 1]; var prop = key.name; var val = decode_param(m[i]); if (val !== undefined || !(hasOwnProperty.call(params, prop))) { params[prop] = val; } } return true; }; </code></pre><p>match函数主要用来匹配path的，当我们向express发送一个http请求时，当前请求对应的是哪个路由，就是通过这个match函数来判断的，如果path中带有参数，match还会把参数提取出来赋值给params，所以说match是整个路由中很重要的一点。</p> <pre class="prettyprint"><code>Layer.prototype.handle_error = function handle_error(error, req, res, next) { var fn = this.handle; if (fn.length !== 4) { // not a standard error handler return next(error); } try { fn(error, req, res, next); } catch (err) { next(err); } }; </code></pre><p>这个是错误处理函数，专门用来处理错误的。</p> <pre class="prettyprint"><code>Layer.prototype.handle_request = function handle(req, res, next) { var fn = this.handle; if (fn.length > 3) { // not a standard request handler return next(); } try { fn(req, res, next); } catch (err) { next(err); } }; </code></pre><p>从上边的代码我们可以看到调用了fn，而这个fn就是layer的handle属性，就是我们定义路由时传入的路由中间件，到这里我们总算找到了我们的路由中间件被执行的地方，是不是很兴奋。好了，到这里我们已经看完了Layer的代码，但Layer到底是做什么的呢，它和Route之间又有什么千丝万缕的联系呢，说说我的理解：</p> <blockquote> <p>每一个Layer对应一个中间件函数，Layer存储了每个路由的path和handle等信息，并且实现了match和handle的功能。而从前边我们已经知道，每个Route都会维护一个Layer数组，所有可以发现Route和Layer是一对多的关系，每个Route代表一个路由，而每个Layer对应的是路由的每一个中间件函数。</p> </blockquote> <p>讲完了Route和Layer的关系，我们再来回头看看Router和Layer的关系，我们再来看看index.js中prop.route的代码：</p> <pre class="prettyprint"><code>proto.route = function route(path) { var route = new Route(path); var layer = new Layer(path, { sensitive: this.caseSensitive, strict: this.strict, end: true }, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route; }; </code></pre><p>从代码我们可以看出来Router每次添加一个route，都会把route包装到layer中，并且将layer添加到自己的stack中，那为什么要把route包装到layer中呢，前边我们已经仔细研究了Layer模块的代码，我们发现Layer具有match和handle的功能，这样我们就可以通过Layer的match来进行route的匹配了。这里有一个关键点我们需要特别讲解下，上边的代码中在创建Layer对象的时候传入的handle函数为<strong>route.dispatch.bind(route)</strong>，我们来看看route.js中的route.dispatch：</p> <pre class="prettyprint"><code>Route.prototype.dispatch = function dispatch(req, res, done) { var idx = 0; var stack = this.stack; if (stack.length === 0) { return done(); } var method = req.method.toLowerCase(); if (method === 'head' && !this.methods['head']) { method = 'get'; } req.route = this; next(); function next(err) { if (err && err === 'route') { return done(); } var layer = stack[idx++]; if (!layer) { return done(err); } if (layer.method && layer.method !== method) { return next(err); } if (err) { layer.handle_error(err, req, res, next); } else { layer.handle_request(req, res, next); } } }; </code></pre><p>我们发现dispatch中通过next()获取stack中的每一个layer来执行相应的路由中间件，这样就保证了我们定义在路由上的多个中间件函数被按照定义的顺序依次执行。到这里我们已经知道了单个路由是被如何执行的，那我们定义的多个路由之间又是如何被依次执行的呢，现在我们来看看index.js中的handle函数：</p> <pre class="prettyprint"><code>proto.handle = function handle(req, res, out) { // middleware and routes var stack = self.stack; next(); function next(err) { // find next matching layer var layer; var match; var route; while (match !== true && idx < stack.length) { layer = stack[idx++]; match = matchLayer(layer, path); route = layer.route; if (match !== true) { continue; } if (!route) { // process non-route handlers normally continue; } } // no match if (match !== true) { return done(layerError); } // this should be done for the layer self.process_params(layer, paramcalled, req, res, function (err) { if (err) { return next(layerError || err); } if (route) { return layer.handle_request(req, res, next); } trim_prefix(layer, layerError, layerPath, path); }); } }; </code></pre><p>上边的代码我进行了处理，删除了一些逻辑，只留下关键部分。从上边的代码我们可以看出，这里也是利用next()，来处理stack中的每一个Layer，这里的stack是Router的stack，stack中存贮了多个route对应的layer，获取到每个layer对象之后，用请求的path与layer进行匹配，此处匹配用的是layer.match，如果能匹配到对应的layer，则获得layer.route，如果route不为空则执行对应的<strong>layer.handle_request()</strong>，如果route为空说明这个layer是通过use()添加的非路由中间件，需要特别说明的是，如果通过use()添加的非路由中间件没有指定path，则会在layer.match中默认返回true，也就是说，没有指定path的非路由中间件会匹配所有的http请求。</p> <p>到这里，我们基本已经说明了router相关的所有内容，想必看到这里你一定会有点晕，我们接下来来重新梳理一下。看看express究竟是如何对http请求进行路由的。</p> <p>当客户端发送一个http请求后，会先进入express实例对象对应的router.handle函数中，router.handle函数会通过next()遍历stack中的每一个layer进行match，如果match返回true，则获取layer.route，执行route.dispatch函数，route.dispatch同样是通过next()遍历stack中的每一个layer，然后执行layer.handle_request，也就是调用中间件函数。直到所有的中间件函数被执行完毕，整个路由处理结束。</p> </div>",
title: "express源码分析之Router",
last_reply_at: "2018-01-21T13:48:10.062Z",
good: true,
top: false,
reply_count: 12,
visit_count: 11017,
create_at: "2016-05-26T10:19:59.631Z",
author: - {
loginname: "leijianning",
avatar_url: "https://avatars.githubusercontent.com/u/14830812?v=3&s=120"
        }
    },
- {
id: "5a5ff20d9d371d4a059eebbe",
author_id: "5a5ff1869288dc8153287f0b",
tab: "ask",
content: "<div class="markdown-text"><p>Node Version: v8.9.3 Egg Version: v2.0.0</p> <p>在使用eggjs框架时遇到如下的问题， <strong>我的测试环境</strong> /etc/hosts 10.200.33.33 <a href="http: //haha.ttt.com">haha.ttt.com</a> 映射到测试服务器</p> <p>在代码中controller层向该地址请求数据 <code>ctx.curl('http://haha.ttt.com', opts);</code> 这里url是nginx服务器的域名，因为是测试环境，所以配置了hosts映射，但此时发出的请求，会返回404， 感觉像是nginx反向代理无法生效</p> <p>直接在环境中使用curl命令去请求域名是可以代理成功的， 但在代码中使用域名就会返回404，和curl直接请求IP是一样的情况，很困惑。。。</p> </div>",
title: "使用egg.js过程中遇到的问题：curl请求到nginx服务器，但目标的反向代理无法生效",
last_reply_at: "2018-01-21T11:52:46.488Z",
good: false,
top: false,
reply_count: 7,
visit_count: 374,
create_at: "2018-01-18T01:02:05.280Z",
author: - {
loginname: "HOTTIN",
avatar_url: "https://avatars2.githubusercontent.com/u/12428754?v=4&s=120"
        }
    },
- {
id: "5a6415cdafa0a121784a8e15",
author_id: "5892cc297274550b057a5cad",
tab: "ask",
content: "<div class="markdown-text"><p>在跑egg-passport-github 的 demo 的时候，发现是直接 egg 的router进行视图渲染的，想问下如何在前后端分离的情况下，怎么做 github 登录</p> <p>在 login.vue 里 直接 location.assign(‘<a href="http: //127.0.0.1:7001/api/passport/github">http://127.0.0.1:7001/api/passport/github</a>’) 这样可以跳转到github授权，但是callback之后又到egg的router里面了，如何再返回到前端并将 user info带回到前端呢？ctx.body = ctx.user;</p> <p>求指教。</p> </div>",
title: "前后端分离(vue + egg) 如何使用egg-passport-github",
last_reply_at: "2018-01-21T10:47:47.353Z",
good: false,
top: false,
reply_count: 1,
visit_count: 185,
create_at: "2018-01-21T04:23:41.722Z",
author: - {
loginname: "EryouHao",
avatar_url: "https://avatars0.githubusercontent.com/u/17328747?v=4&s=120"
        }
    },
- {
id: "5a6169cf9d371d4a059eec38",
author_id: "584139e9539c22b15689981c",
tab: "ask",
content: "<div class="markdown-text"><p>我们的业务需求，需要创建N多个小文件，每个文件里存一个json对象。 一般的做法是：拿到json对象，stringify，然后以字符串形式存到一个特定的文件里。需要的时候再从特定的文件里读出来，parse一下，然后再用。</p> <p>请问，有没有某个包，更优雅的实现这个操作啊？ 多谢。</p> </div>",
title: "请问，有哪个包可以方便的“存取”一个大的json对象到一个文件里？",
last_reply_at: "2018-01-21T10:20:25.689Z",
good: false,
top: false,
reply_count: 15,
visit_count: 318,
create_at: "2018-01-19T03:45:19.072Z",
author: - {
loginname: "hz0324",
avatar_url: "https://avatars0.githubusercontent.com/u/5040078?v=4&s=120"
        }
    },
- {
id: "5a5c1c75a3692d014f4f147f",
author_id: "4efc278525fa69ac69000141",
tab: "ask",
content: "<div class="markdown-text"><p>在浏览器环境习惯了, 记不起来 Node.js 以前是不是这样. 我的想法是把一些逻辑放在 setTimeout 的事件队列当中执行, 这样代码报错了, 主进程不受到影响, 而报错是直接打印在 Console 里的. 可是实际测试了一下, setTimeout 当中代码报错, 整个 Node.js 进程直接退出了. 除了 try/catch 还有没有方式可以在 Node.js 当中模拟浏览器的行为? Node.js 当中一开始就这样吗?</p> <p>示例代码:</p> <pre class="prettyprint language-js"><code>var http = require('http'); http.createServer(function(req, res) { return a(2); }).listen(3000); </code></pre></div>",
title: "setTimeout 报错导致整个进程退出, 是正常行为吗",
last_reply_at: "2018-01-21T06:08:31.848Z",
good: false,
top: false,
reply_count: 3,
visit_count: 396,
create_at: "2018-01-15T03:13:57.527Z",
author: - {
loginname: "jiyinyiyong",
avatar_url: "https://avatars0.githubusercontent.com/u/449224?v=4&s=120"
        }
    },
- {
id: "5a54132299d207fa49f5cd33",
author_id: "5595d50047e6bdc30297ed1a",
tab: "share",
content: "<div class="markdown-text"><p>DoraCMS 之前的版本是缺少用户发布文章这个功能的，之前不愿意加，主要是因为还没准备好做成类似论坛的模式，而只是简单的内容发布系统。考虑到前台会员发布信息的需求比较多，这次版本更新加上了，希望可以给各位建站带来便利。</p> <p>本次版本发布主要更新点：</p> <p>1、用户中心添加文章功能，注册用户可以发布文章了，支持markdown语法</p> <p>2、优化webpack打包流程，压缩lodash，拆分element-ui</p> <p>3、服务端异常处理</p> <p>4、用户留言xss处理</p> <p>5、修复文章点击量不准确的问题</p> <p>6、修复在开发环境下，后台切换登录超级管理员和测试管理员，左侧菜单没有变化的问题</p> <p>7、首页添加了用户留言模块，以及推荐模块</p> <p>8、优化相关样式和界面布局</p> <p>9、修复了其它bug</p> <p>更新方法：</p> <p>1、checkout 最新 2.0.5 代码</p> <p>2、删除 node_modules,重新安装依赖包</p> <p>3、启动数据库，执行npm run dev</p> <p>你可以到github上获取到最新版本的代码： <a href="https: //github.com/doramart/DoraCMS">DoraCMS</a></p> </div>",
title: "DoraCMS v2.0.5 发布，Node.js CMS 内容管理框架",
last_reply_at: "2018-01-21T03:58:40.263Z",
good: false,
top: false,
reply_count: 3,
visit_count: 598,
create_at: "2018-01-09T00:56:02.654Z",
author: - {
loginname: "doramart",
avatar_url: "https://avatars1.githubusercontent.com/u/11911066?v=4&s=120"
        }
    },
- {
id: "5930cf8203dba3510d8a62e1",
author_id: "5779db49fb1d649f05fec70b",
tab: "share",
content: "<div class="markdown-text"><h4>什么是jwt</h4> <p>这个文章已经解释得很清楚了<a href="http: //www.jianshu.com/p/576dbf44b2ae">传送门</a></p> <h4>jwt和session的区别</h4> <p><strong>session</strong>：一般用于服务端存储信息，其生命周期会随服务器重启而终止，或者由代码清除。 常常用于web应用登录状态的保存，但是在ios/android应用中，网络请求不包含session信息，因此服务端session无法使用，这是就产生了token。 <strong>token</strong>：作为用户状态的凭证。用户登录成功后，服务端生成一条token信息，该token可以包含用户id，过期时间等信息，经过加密算法返回给客户端，客户端访问时将该token带上，服务端做权限校验。</p> <h4>废话少说，直接上代码</h4> <p><strong>auth.service.js核心代码，用于生成token和验证token：</strong> 1、安装express-jwt <a href="https://github.com/auth0/express-jwt">github地址</a> 2、定义产生token方法，role为附加信息，用来做角色权限控制 config.secrets.session为密钥，一个字符串。</p> <pre class="prettyprint"><code>module.exports.signToken = (id, role) => { return jwt.sign({_id: id, role}, config.secrets.session, { expiresIn: 60 * 60 * 5 // 过期时间 表示5小时过期 }) } </code></pre><p>3、定义验证token方法isAuthenticated，以下是截取部分关键代码。</p> <pre class="prettyprint"><code>// 从请求头获取token var token = req.headers.authorization.split('Bearer ')[1] // 查找数据库是否有该token UserController.findByToken(token).then((user) => { if (user) { //验证token是否过期 validateJwt(req, res, next); }else{ return res.status(401).end(); } }) </code></pre><p><strong>开发登录和权限验证功能：</strong> 1、定义登录方法</p> <pre class="prettyprint"><code>module.exports.login = (req, res) => { var loginId = req.body.loginId var password = req.body.password let token // 数据库查找用户 return User.findOne({ loginId: loginId }).exec() .then(user => { // 验证密码是否正确 if (user && user.authenticate(password)) { // 产生token token = jwt.sign({ _id: user._id }, config.secrets.session, { expiresIn: 60 * 60 * 5 }) user.token = token var updateUser = JSON.parse(JSON.stringify(user)) delete updateUser._id User.findOneAndUpdate({ _id: user._id }, updateUser).exec() // 返回给客户端 res.status(200).json({ token }).end() } else { return res.status(401).end() } }) } </code></pre><p>2、验证用户身份，参考auth.service.js isAuthenticated方法</p> <h4>问题来了</h4> <p><strong>如何刷新token?</strong> express-jwt这个库没有提供刷新token过期时间的方法，因此我们需要后端重新创建token，让客户端更新token。为了保证安全性，我们不能因token失效就刷新，那这样token就有可能被黑客嗅探利用。 因此，解决方案应该是当token过期时间小于一小时，后端返回新的token，token放在返回头，当前端发现返回头带有token信息，即更新token。 当token已经过期，就返回401，提示用户重新登录。</p> <h4>项目源码 <a href="https://github.com/zhengguorong/h5maker">github地址</a></h4> <h4>项目演示</h4> <p><img src="http://upload-images.jianshu.io/upload_images/6276836-272dadde2340c8fe.gif?imageMogr2/auto-orient/strip" alt="项目演示"></p> </div>",
title: "jwt在node中的应用",
last_reply_at: "2018-01-21T03:18:19.862Z",
good: false,
top: false,
reply_count: 10,
visit_count: 2038,
create_at: "2017-06-02T02:37:54.756Z",
author: - {
loginname: "zhengguorong",
avatar_url: "https://avatars0.githubusercontent.com/u/2757932?v=4&s=120"
        }
    },
- {
id: "5a63ff23afa0a121784a8e10",
author_id: "5a38ceb89807389a1809f52a",
tab: "ask",
content: "<div class="markdown-text"><p>2018也过去了二十天了。但好像没有看到关于Node.js的总结和发展展望,如果可以的话还是希望有大佬做一下。指导新人下一步的学习(哪些技术正在兴起,重点学习,哪些技术在衰落,可以放一边)</p> </div>",
title: "有没有大佬做一份Node.js在2017的发展总结和2018展望？",
last_reply_at: "2018-01-21T02:46:59.489Z",
good: false,
top: false,
reply_count: 0,
visit_count: 215,
create_at: "2018-01-21T02:46:59.489Z",
author: - {
loginname: "JeromeYangtao",
avatar_url: "https://avatars1.githubusercontent.com/u/22118243?v=4&s=120"
        }
    },
- {
id: "5a609e28ce45d44045146131",
author_id: "59f9da9ab381c1737d7ccb9f",
tab: "ask",
content: "<div class="markdown-text"><p>egg-socket.io里怎么监听connect event啊😑😑</p> </div>",
title: "egg-socket.io里怎么监听connect event啊😑😑",
last_reply_at: "2018-01-20T16:28:27.301Z",
good: false,
top: false,
reply_count: 2,
visit_count: 265,
create_at: "2018-01-18T13:16:24.648Z",
author: - {
loginname: "Alexerx",
avatar_url: "https://avatars3.githubusercontent.com/u/22076610?v=4&s=120"
        }
    }
]